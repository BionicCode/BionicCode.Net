<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BionicCode.Utilities.Net.Common</name>
    </assembly>
    <members>
        <member name="T:BionicCode.Utilities.Net.AccessModifier">
            <summary>
            
            </summary>
            <remarks>
            The enum values are ordered from least restrictive to most restrictive. Therefore, the hierarchy can be determined by comparing their integral numeric.
            <br/>For example, using the less than operator <c>&lt;</c> to compare two <see cref="T:BionicCode.Utilities.Net.AccessModifier"/> values like <c>Console.WriteLine(AccessModifier.Public &lt; AccessModifier.Private)</c> would print "True", expressing that <see langword="Public"/> is less restrictive than <see langword="private"/>.
            
            ╔════════════════════════════════════════╦════════╦════════════════════╦══════════╦═══════════╦═══════════════════╦═════════╗
            ║ Caller's location                      ║ public ║ protected internal ║ internal ║ protected ║ private protected ║ private ║
            ╠════════════════════════════════════════╬════════╬════════════════════╬══════════╬═══════════╬═══════════════════╬═════════╣
            ║ Within the class                       ║   ✓    ║          ✓         ║     ✓    ║    ✓      ║         ✓         ║    ✓    ║
            ╠════════════════════════════════════════╬════════╬════════════════════╬══════════╬═══════════╬═══════════════════╬═════════╣
            ║ Derived class (same assembly)          ║   ✓    ║          ✓         ║     ✓    ║    ✓      ║         ✓         ║    ╳    ║
            ╠════════════════════════════════════════╬════════╬════════════════════╬══════════╬═══════════╬═══════════════════╬═════════╣
            ║ Non-derived class (same assembly)      ║   ✓    ║          ✓         ║     ✓    ║    ╳      ║         ╳         ║    ╳    ║
            ╠════════════════════════════════════════╬════════╬════════════════════╬══════════╬═══════════╬═══════════════════╬═════════╣
            ║ Derived class (different assembly)     ║   ✓    ║          ✓         ║     ╳    ║    ✓      ║         ╳         ║    ╳    ║
            ╠════════════════════════════════════════╬════════╬════════════════════╬══════════╬═══════════╬═══════════════════╬═════════╣
            ║ Non-derived class (different assembly) ║   ✓    ║          ╳         ║     ╳    ║    ╳      ║         ╳         ║    ╳    ║
            ╚════════════════════════════════════════╩════════╩════════════════════╩══════════╩═══════════╩═══════════════════╩═════════╝
            </remarks>
        </member>
        <member name="F:BionicCode.Utilities.Net.AccessModifier.Default">
            <summary>
            Should be interpreted as <see langword="internal"/> per language default.
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.AccessModifier.Public">
            <summary>
            Represents the <see langword="public"/> modifier.
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.AccessModifier.ProtectedInternal">
            <summary>
            Represents the <see langword="protected internal"/> modifier.
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.AccessModifier.Internal">
            <summary>
            Represents the <see langword="internal"/> modifier.
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.AccessModifier.Protected">
            <summary>
            Represents the <see langword="protected"/> modifier.
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.AccessModifier.PrivateProtected">
            <summary>
            Represents the <see langword="private protected"/> modifier.
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.AccessModifier.Private">
            <summary>
            Represents the <see langword="private"/> modifier.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.AsyncRelayCommandCommon">
            <summary>
            A reusable command that encapsulates the implementation of <see cref="T:System.Windows.Input.ICommand"/> with support for async/await command delegates. 
            <br/>Enables instant creation of an ICommand without implementing the ICommand interface for each command.
            The <see cref="T:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1"/> accepts asynchronous command handlers and supports data bindng to properties like <see cref="!:IsExecuting"/> by implementing <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>.
            <br/>Call and await the <see cref="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.ExecuteAsync"/> method or one of its overloads to execute the command explicitly asynchronously.
              <seealso cref="T:System.Windows.Input.ICommand" />
            </summary>
            <remarks><c>AsyncRelayCommandCommon</c> implements <see cref="T:System.Windows.Input.ICommand" />. In case the <see cref="T:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1"/> is executed explicitly, especially with an asynchronous command handler registered, it is highly recommended to invoke the awaitable <see cref="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.ExecuteAsync"/> or its overloads instead.</remarks>
        </member>
        <member name="F:BionicCode.Utilities.Net.AsyncRelayCommandCommon.executeCancellableAsyncNoParamDelegate">
            <summary>
            The registered parameterless async execute delegate that supports cancellation.
            </summary>
            <value>
            A delegate that supports cancellation, but takes no command parameter and returns a <see cref="T:System.Threading.Tasks.Task"/>.</value>
        </member>
        <member name="F:BionicCode.Utilities.Net.AsyncRelayCommandCommon.executeCancellableNoParamDelegate">
            <summary>
            The registered parameterless synchronous execute delegate that supports cancellation.
            </summary>
            <value>
            A delegate that suppoprts cancellation, but takes no command parameter and returns void.</value>
        </member>
        <member name="F:BionicCode.Utilities.Net.AsyncRelayCommandCommon.canExecuteNoParamDelegate">
            <summary>
            The registered parameterless CanExecute delegate.
            </summary>
            <value>
            <c>true</c> if the command can execute, otherwise <c>false</c>.</value>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.#ctor(System.Action)">
            <summary>
              Creates a new parameterless synchronous command that can always execute (<see cref="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.CanExecute"/> will always return <c>true</c>).
            </summary>
            <param name="executeNoParam">The awaitable execution handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.#ctor(System.Action{System.Threading.CancellationToken})">
            <summary>
              Creates a new parameterless synchronous command that can always execute (<see cref="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.CanExecute"/> will always return <c>true</c>)
              <br/>and supports cancellation.
            </summary>
            <param name="executeNoParam">The awaitable execution handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.#ctor(System.Func{System.Threading.Tasks.Task})">
            <summary>
              Creates a new parameterless asynchronous command that can always execute (<see cref="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.CanExecute"/> will always return <c>true</c>).
            </summary>
            <param name="executeAsyncNoParam">The awaitable execution handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.#ctor(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>
              Creates a new parameterless asynchronous command that can always execute (<see cref="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.CanExecute"/> will always return <c>true</c>)
              <br/>and supports cancellation.
            </summary>
            <param name="executeAsyncNoParam">The awaitable execution handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.#ctor(System.Action,System.Func{System.Boolean})">
            <summary>
              Creates a new parameterless synchronous command.
            </summary>
            <param name="executeNoParam">The execution handler.</param>
            <param name="canExecuteNoParam">The execution status handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.#ctor(System.Func{System.Threading.Tasks.Task},System.Func{System.Boolean})">
            <summary>
              Creates a parameterless new asynchronous command.
            </summary>
            <param name="executeAsyncNoParam">The awaitable execution handler.</param>
            <param name="canExecuteNoParam">The execution status handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.#ctor(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{System.Boolean})">
            <summary>
              Creates a new parameterless asynchronous command that supports cancellation and does not take a command parameter.
            </summary>
            <param name="executeAsync">The awaitable execution handler.</param>
            <param name="canExecute">The can execute handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.#ctor(System.Action{System.Threading.CancellationToken},System.Func{System.Boolean})">
            <summary>
              Creates a new parameterless synchronous command that supports cancellation.
            </summary>
            <param name="executeCancellable">The awaitable execution handler.</param>
            <param name="canExecute">The can execute handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.CanExecute">
            <summary>
              Determines whether this AsyncRelayCommandCommon can execute.
            </summary>
            <returns><c>true</c> if this command can be executed, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.ExecuteAsync">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.ExecuteAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.ExecuteAsync(System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.ExecuteAsync(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
              Executes the AsyncRelayCommand on the current command target asynchronously.
            </summary>
            <param name="timeout">A <seealso cref="T:System.TimeSpan"/> to specify the timeout of the operation. 
            <br/>A value of <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> (or a <see cref="T:System.TimeSpan"/> that represents -1) will specifiy an infinite time out. 
            <br/>A value of <see cref="F:System.TimeSpan.Zero"/> will cancel the operation immediately.</param>
            <param name="cancellationToken">An instance of <seealso cref="T:System.Threading.CancellationToken"/> to cancel the executing command delegate.</param>
            <remarks>If the registered command handler is asynchronous (awaitable), then the execution is asynchronous otherwise the delegate is executed synchronously. 
            <br/><br/>Repeated or concurrent calls are synchronized.
            </remarks>
            <exception cref="T:System.OperationCanceledException">If the executing command delegate was cancelled.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout>>"/>.TotalMilliseconds is less than -1 or greater than <see cref="F:System.Int32.MaxValue"/> (or <see cref="F:System.UInt32.MaxValue"/> - 1 on some versions of .NET). Note that this upper bound is more restrictive than <see cref="F:System.TimeSpan.MaxValue"/>.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.System#Windows#Input#ICommand#Execute(System.Object)">
            <inheritdoc />
        </member>
        <member name="P:BionicCode.Utilities.Net.AsyncRelayCommandCore.CanBeCanceled">
            <inheritdoc />
        </member>
        <member name="P:BionicCode.Utilities.Net.AsyncRelayCommandCore.CurrentCancellationToken">
            <inheritdoc />
        </member>
        <member name="P:BionicCode.Utilities.Net.AsyncRelayCommandCore.HasPending">
            <inheritdoc/>
        </member>
        <member name="P:BionicCode.Utilities.Net.AsyncRelayCommandCore.IsCancelled">
            <inheritdoc/>
        </member>
        <member name="P:BionicCode.Utilities.Net.AsyncRelayCommandCore.IsExecuting">
            <inheritdoc/>
        </member>
        <member name="F:BionicCode.Utilities.Net.AsyncRelayCommandCore.MaxDegreeOfParallelism">
            <inheritdoc/>
        </member>
        <member name="P:BionicCode.Utilities.Net.AsyncRelayCommandCore.PendingCount">
            <inheritdoc/>
        </member>
        <member name="E:BionicCode.Utilities.Net.AsyncRelayCommandCore.ExecutingCommandCancelled">
            <inheritdoc />
        </member>
        <member name="E:BionicCode.Utilities.Net.AsyncRelayCommandCore.PendingCommandCancelled">
            <inheritdoc />
        </member>
        <member name="E:BionicCode.Utilities.Net.AsyncRelayCommandCore.PropertyChanged">
            <inheritdoc />
        </member>
        <member name="E:BionicCode.Utilities.Net.AsyncRelayCommandCore.CanExecuteChanged">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCore.CancelExecuting">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCore.CancelExecuting(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCore.CancelPending">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCore.CancelPending(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCore.CancelAll">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCore.CancelAll(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCore.InvalidateCommand">
            <inheritdoc/>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCore.OnCanExecuteChanged">
            <summary>
            Raises the <see cref="E:System.Windows.Input.ICommand.CanExecuteChanged"/> event.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCore.OnCanExecuteChanged(System.Object,System.EventArgs)">
            <summary>
            Raises the <see cref="E:System.Windows.Input.ICommand.CanExecuteChanged"/> event.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCore.OnPropertyChanged(System.String)">
            <summary>
            Raises the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCore.OnPendingCommandsCancelled">
            <summary>
            Raises the <see cref="!:IAsyncRelayCommandCommon.PendingCommandCancelled"/> event.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCore.OnExecutingCommandCancelled">
            <summary>
            Raises the <see cref="!:IAsyncRelayCommandCommon.ExecutingCommandCancelled"/> event.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.IgnoreAttribute">
            <summary>
            Attribute to decorate types or members.<br/>
            For example, the attribute is used by the <see cref="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToDataTable``1(System.Collections.Generic.IEnumerable{``0})"/> extension method.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.IgnoreInObjectGraphAttribute">
            <summary>
            Attribute to decorate class members that should be ignored when traversing an instance's object graph.
            </summary>
            <remarks>The <see cref="T:BionicCode.Utilities.Net.IgnoreInObjectGraphAttribute"/> can be used in conjunction with the <see cref="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToDictionary(System.Object)"/> and <see cref="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToFlatDictionary(System.Object)"/> extension methods.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.IgnoreInObjectGraphAttribute.#ctor">
            <summary>
            The default constructor
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.ProfileAttribute">
            <summary>
            Use to decorate a member like method, constructor or property that should be profiled.  /// 
            </summary>
            <remarks>
            To start profiling create a configurator by calling <see cref="M:BionicCode.Utilities.Net.Profiler.CreateProfilerBuilder``1"/>. This returns a <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/> for a particular <see cref="T:System.Type"/> that allows the configuration of the profiling session.
            <br/>Finalize the step by calling <see cref="M:BionicCode.Utilities.Net.ProfilerBuilder.RunAsync(System.Threading.CancellationToken)"/> to start the profiling for the current type.
            <para>
            By default the profiler uses the latest released .NET runtime to execute the profiling. Set the <seealso cref="P:BionicCode.Utilities.Net.ProfileAttribute.TargetFramework"/> property to define
            </para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfileAttribute.#ctor(System.String,System.Int32)">
            <summary>
            Constructor. 
            This default constructor configures the profiler to use the latest released .NET runtime to execute the profiling. 
            Set the <seealso cref="P:BionicCode.Utilities.Net.ProfileAttribute.TargetFramework"/> property or use the overload to configure a different .NET runtme.
            </summary>
            <param name="sourceFilePath"></param>
            <param name="lineNumber"></param>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfileAttribute.#ctor(BionicCode.Utilities.Net.Runtime,System.String,System.Int32)">
            <summary>
            Constructor. 
            </summary>
            <param name="targetFramework">The target .NET runtime that the profiler must use to execute the profiled code.</param>
            <param name="sourceFilePath"></param>
            <param name="lineNumber"></param>
        </member>
        <member name="T:BionicCode.Utilities.Net.ProfilerArgumentAttribute">
            <summary>
            Use to decorate a member like method, constructor or property that should be profiled with particular argument list.
            </summary>
            <remarks>
            To start profiling create a configurator by calling <see cref="M:BionicCode.Utilities.Net.Profiler.CreateProfilerBuilder``1"/>. This returns a <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/> for a particular <see cref="T:System.Type"/> that allows the configuration of the profiling session.
            <br/>Finalize the step by calling <see cref="M:BionicCode.Utilities.Net.ProfilerBuilder.RunAsync(System.Threading.CancellationToken)"/> to start the profiling for the current type.
            <para>
            A member can be decorated with multiple <see cref="T:BionicCode.Utilities.Net.ProfilerArgumentAttribute"/> attributes. This is useful to emulate real-world usage where the input is dynamic and may impact the perfomance of the profiled member. 
            <br/>Each <see cref="T:BionicCode.Utilities.Net.ProfilerArgumentAttribute"/> results in an profiling iteration. If the configured iterations of the <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/> exceed the number of <see cref="T:BionicCode.Utilities.Net.ProfilerArgumentAttribute"/> attributes, then the profiler will alterante between the argument lists.
            <br/>The default number of iterations is <c>1</c> and can be customized by calling <see cref="M:BionicCode.Utilities.Net.ProfilerBuilder.SetIterations(System.Int32)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerArgumentAttribute.#ctor(System.Object[])">
            <summary>
            Constructor to request the ordered argument list for the decorated member.
            </summary>
            <param name="arguments">The argument list ordered by their position.</param>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerArgumentAttribute.Arguments">
            <summary>
            Gets the argument list. It is assumed that the provided list is ordered by position.
            </summary>
            <value>
            The argument list that is used to profile the decorated member.
            </value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerArgumentAttribute.Index">
            <summary>
            The index used to get/set an indexer.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.ProfilerFactoryAttribute">
            <summary>
            Used to decorate a <see langword="static"/> member that returns an instance for the currently profiled type.
            </summary>
            <remarks>This attribute can be used in case the type has no default constructor, or profiling requires a specially initialized instance.
            <br/>The default constructor must be an instance constructor and can be defined with any access modifier (e.g. <see langword="public"/> or <see langword="private"/>).
            <br/>The factory member must be <see langword="static"/> and can be a method, property or field and must return an instance of the type that declares the profiled memeber.
            <para></para>
            <br/>The <see cref="T:BionicCode.Utilities.Net.Profiler"/> creates an instance of the profiled type using one of the following providers ranked by prcedence:
            <br/>
            <list type="number">
            <item>It first checks if the type has a <see langword="static"/> member that is decorated with the <see cref="T:BionicCode.Utilities.Net.ProfilerFactoryAttribute"/> and returns the same type as the type that declares the profiled member. 
            <br/>The first memeber that satisfies the constraints is used to obtain a pre-configured instance in order to invoked the profiled member.</item>
            <item>If no such attribute was found, it tries to find a parameterless instance constructor. This constrcutor can be <see langword="public"/>, <see langword="private"/>, or of any other access modifier.</item>
            <item>If no parameterles constructor was found and the profiled member is not a <see langword="static"/> member a <see cref="T:System.MissingMemberException"/> exception is thrown.</item>
            </list>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerFactoryAttribute.#ctor">
            <summary>
            Constructor without any required parameters.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerFactoryAttribute.#ctor(System.Object[])">
            <summary>
            Constructor without any required parameters.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.CartesianPoint">
            <summary>
            Point - Defaults to 0,0
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.CartesianPoint.#ctor(System.Double,System.Double)">
            <summary>
            Constructor which accepts the X and Y values
            </summary>
            <param name="x">The value for the X coordinate of the new Point</param>
            <param name="y">The value for the Y coordinate of the new Point</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.CartesianPoint.Offset(System.Double,System.Double)">
            <summary>
            Offset - update the location by adding offsetX to X and offsetY to Y
            </summary>
            <param name="xOffset"> The offset in the x dimension </param>
            <param name="yOffset"> The offset in the y dimension </param>
        </member>
        <member name="P:BionicCode.Utilities.Net.CartesianPoint.X">
            <summary>
            The X value of the point. The default value is '0'.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.CartesianPoint.Y">
            <summary>
            The Y value of the point. The default value is '0'.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.CartesianPoint.Equals(BionicCode.Utilities.Net.CartesianPoint)">
            <inheritdoc/>
        </member>
        <member name="M:BionicCode.Utilities.Net.CartesianPoint.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:BionicCode.Utilities.Net.CartesianPoint.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:BionicCode.Utilities.Net.CartesianPoint.ToString">
            <inheritdoc/>
        </member>
        <member name="M:BionicCode.Utilities.Net.CartesianPoint.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:BionicCode.Utilities.Net.CartesianPoint.CompareTo(BionicCode.Utilities.Net.CartesianPoint)">
            <inheritdoc/>
            <remarks>This method compares the <see cref="P:BionicCode.Utilities.Net.CartesianPoint.X"/> value. When the <see cref="P:BionicCode.Utilities.Net.CartesianPoint.X"/> value of the current instance is smaller the value of <paramref name="other"/> then the current instance precedes <paramref name="other"/>.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.CartesianPoint.op_Equality(BionicCode.Utilities.Net.CartesianPoint,BionicCode.Utilities.Net.CartesianPoint)">
            <summary>
            Compares two Point instances for exact equality.
            Note that double values can acquire error when operated upon, such that
            an exact comparison between two values which are logically equal may fail.
            Furthermore, using this equality operator, Double.NaN is not equal to itself.
            </summary>
            <returns>
            bool - true if the two Point instances are exactly equal, false otherwise
            </returns>
            <param name='left'>The first Point to compare</param>
            <param name='right'>The second Point to compare</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.CartesianPoint.op_Inequality(BionicCode.Utilities.Net.CartesianPoint,BionicCode.Utilities.Net.CartesianPoint)">
            <summary>
            Compares two Point instances for exact equality.
            Note that double values can acquire error when operated upon, such that
            an exact comparison between two values which are logically equal may fail.
            Furthermore, using this equality operator, Double.NaN is not equal to itself.
            </summary>
            <returns>
            bool - true if the two Point instances are exactly equal, false otherwise
            </returns>
            <param name='left'>The first Point to compare</param>
            <param name='right'>The second Point to compare</param>
        </member>
        <member name="T:BionicCode.Utilities.Net.ObservableQueue`1">
            <summary>
            A <see cref="T:System.Collections.Generic.Queue`1"/> that implements <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> and <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>.
            <br/> Since the behavior itself is not changed, see <see cref="T:System.Collections.Generic.Queue`1"/> for a detailed API documentation.
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="E:BionicCode.Utilities.Net.ObservableQueue`1.PropertyChanged">
            <inheritdoc/>
        </member>
        <member name="E:BionicCode.Utilities.Net.ObservableQueue`1.CollectionChanged">
            <inheritdoc/>
        </member>
        <member name="M:BionicCode.Utilities.Net.ObservableQueue`1.Enqueue(`0)">
            <summary>
            Adds an object to the end of the <see cref="T:System.Collections.Generic.Queue`1"/>.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.Queue`1"/>. The value can be <c>null</c> for reference types.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.ObservableQueue`1.Dequeue">
            <summary>
            Removes and returns the object at the beginning of the <see cref="T:System.Collections.Generic.Queue`1"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.ObservableQueue`1.TryDequeue(`0@)">
            <summary>
            Removes the object at the beginning of the <see cref="T:System.Collections.Generic.Queue`1"/>, and copies it to the result parameter.
            </summary>
            <param name="result">The removed object.</param>
            <returns><c>true</c> if the object is successfully removed; <c>false</c> if the <see cref="T:System.Collections.Generic.Queue`1"/> is empty.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.ObservableQueue`1.Clear">
            <summary>
            Removes all objects from the <see cref="T:System.Collections.Generic.Queue`1"/>.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.PropertyValidationDelegate`1">
            <summary>
            A delegate that can be passed to a <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,System.Func{``0,System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}},``0@,System.String)"/> and overload to provide a custom validation method.
            </summary>
            <typeparam name="TValue">The type of the value to validate.</typeparam>
            <param name="propertyValue">The value to validate.</param>
            <returns>The validation result.</returns>
        </member>
        <member name="T:BionicCode.Utilities.Net.PropertyValidationDelegateAsync`1">
            <summary>
            A delegate that can be passed to a <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueAsync``1(``0,``0,System.Func{``0,System.Threading.Tasks.Task{System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}}},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)"/> and overload 
            <br/>to provide a custom asynchroous validation method.
            </summary>
            <typeparam name="TValue">The type of the value to validate.</typeparam>
            <param name="propertyValue">The value to validate.</param>
            <returns>The validation result.</returns>
        </member>
        <member name="T:BionicCode.Utilities.Net.PropertyValueChangedEventHandler`1">
            <summary>
            PropertyChanged event handler that supports standard property changed signature events with additional old value and new value parameters.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:BionicCode.Utilities.Net.SetBackingFieldDelegate`1">
            <summary>
            A delegate that defines a method to set the backing field of a property.
            </summary>
            <typeparam name="TValue">The type of the property.</typeparam>
            <param name="newValue">The value to be assigned to the backingfield of the property.</param>
            <remarks>This delegate is required to set the backingfield of a property by an async method. Async methods can't define <c>ref</c> parameters.</remarks>
        </member>
        <member name="T:BionicCode.Utilities.Net.ProfilerLoggerDelegate">
            <summary>
            A delegate to print the results of the <see cref="T:BionicCode.Utilities.Net.Profiler"/> to a output (e.g. file).
            </summary>
            <param name="results">A <see cref="T:BionicCode.Utilities.Net.ProfilerBatchResult"/> object that holds the results of the benchmark run.</param>
            <remarks>
            <para>Read the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/> property to obtain a print-ready output of the bencmark results.
            <br/>This property returns a default table of the following format:
            <br/>
            <code>
                      ╭───────────────┬────────────────────────────┬────────────────╮
                      | Iteration #   │ Duration [ms]              │ Is cancelled   |
                      ┝━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━┥
                      │ 1             │                     1.0512 │ False          |
                      │ 2             │                     1.0020 │ False          │
                      │ 3             │                     0.8732 │ False          │
                      │ 4             │                     0.0258 │ True (ignored) │
                      │ 5             │                     0.9943 │ False          │
            ╭═════════╧═══════════════╪════════════════════════════┼────────────────┤
            │ Total:    -             │                     3.9207 │                │
            │ Min:      3             │                     0.8732 │                │
            │ Max:      1             │                     1.0512 │                │
            │ Average:  -             │                     0.9802 │                │
            ╰─────────────────────────┴────────────────────────────┴────────────────╯
            </code></para>
            API docs: <see href="https://sampoh.de/github/docs/bioniccode.net/api/BionicCode.Utilities.Net.ProfilerLoggerDelegate.html">void ProfilerLoggerDelegate(ProfilerBatchResult results, string preformattedOutput)</see>
            </remarks>
        </member>
        <member name="T:BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate">
            <summary>
            An asynchronous delegate to print the results of the <see cref="T:BionicCode.Utilities.Net.Profiler"/> to a output (e.g. file).
            </summary>
            <param name="results">A <see cref="T:BionicCode.Utilities.Net.ProfilerBatchResult"/> object that holds the results of the benchmark run.</param>
            <remarks>
            <para>Read the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/> property to obtain a print-ready output of the bencmark results.
            <br/>This property returns a default table of the following format:
            <br/>
            <code>
                      ╭───────────────┬────────────────────────────┬────────────────╮
                      | Iteration #   │ Duration [ms]              │ Is cancelled   |
                      ┝━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━┥
                      │ 1             │                     1.0512 │ False          |
                      │ 2             │                     1.0020 │ False          │
                      │ 3             │                     0.8732 │ False          │
                      │ 4             │                     0.0258 │ True (ignored) │
                      │ 5             │                     0.9943 │ False          │
            ╭═════════╧═══════════════╪════════════════════════════┼────────────────┤
            │ Total:    -             │                     3.9207 │                │
            │ Min:      3             │                     0.8732 │                │
            │ Max:      1             │                     1.0512 │                │
            │ Average:  -             │                     0.9802 │                │
            ╰─────────────────────────┴────────────────────────────┴────────────────╯
            </code></para>
            API docs: <see href="https://sampoh.de/github/docs/bioniccode.net/api/BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate.html">Task ProfilerLoggerAsyncDelegate(ProfilerBatchResult results, string preformattedOutput)</see>
            </remarks>
        </member>
        <member name="T:BionicCode.Utilities.Net.ProgressChangedEventHandler">
            <summary>
            Eventhandler for the <see cref="E:BionicCode.Utilities.Net.IProgressReporterCommon.ProgressChanged"/> event.
            </summary>
            <param name="sender">the event source.</param>
            <param name="e">The event data.</param>
        </member>
        <member name="T:BionicCode.Utilities.Net.Environment">
            <summary>
            A collection of reusable static helper methods related to the development environment.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.Environment.IsDebugModeEnabled">
            <summary>
            Checks whether the application is running in debug mode.
            </summary>
            <value><see langword="true"/> if the application is currently in debug mode. Otherwise <see langword="false"/>,</value>
        </member>
        <member name="T:BionicCode.Utilities.Net.EventAggregator">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterObservable(System.Object,System.Collections.Generic.IEnumerable{System.String})">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRemoveObservable(System.Object,System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRemoveObservable(System.Object,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterObserver(System.String,System.Type,System.Delegate)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterObserver(System.String,System.Type,System.Delegate,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterObserver(System.String,System.Type,System.Delegate,System.Threading.SynchronizationContext)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterObserver``1(System.String,System.Type,System.EventHandler{``0})">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterObserver``1(System.String,System.Type,System.EventHandler{``0},System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterObserver``1(System.String,System.Type,System.EventHandler{``0},System.Threading.SynchronizationContext)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterGlobalObserver(System.String,System.Delegate)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterGlobalObserver(System.String,System.Delegate,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterGlobalObserver(System.String,System.Delegate,System.Threading.SynchronizationContext)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterGlobalObserver``1(System.String,System.EventHandler{``0})">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterGlobalObserver``1(System.String,System.EventHandler{``0},System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterGlobalObserver``1(System.String,System.EventHandler{``0},System.Threading.SynchronizationContext)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterGlobalObserver(System.Delegate)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterGlobalObserver(System.Delegate,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterGlobalObserver(System.Delegate,System.Threading.SynchronizationContext)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterGlobalObserver``1(System.EventHandler{``0})">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterGlobalObserver``1(System.EventHandler{``0},System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRegisterGlobalObserver``1(System.EventHandler{``0},System.Threading.SynchronizationContext)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRemoveObserver(System.String,System.Type,System.Delegate)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRemoveObserver``1(System.String,System.Type,System.EventHandler{``0})">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRemoveGlobalObserver(System.String,System.Delegate)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRemoveGlobalObserver``1(System.String,System.EventHandler{``0})">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRemoveGlobalObserver(System.Delegate)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRemoveGlobalObserver``1(System.EventHandler{``0})">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRemoveAllObservers(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRemoveAllObservers(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.EventAggregator.TryRemoveAllObservers(System.String)">
            <inheritdoc />
        </member>
        <member name="T:BionicCode.Utilities.Net.WrongEventHandlerSignatureException">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.WrongEventHandlerSignatureException.#ctor">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.WrongEventHandlerSignatureException.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.WrongEventHandlerSignatureException.#ctor(System.String,System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.WrongEventHandlerSignatureException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="T:BionicCode.Utilities.Net.HelperExtensionsCommon">
            <summary>
            A collection of extension methods for various default types
            </summary>
            <summary>
            A collection of extension methods for various default types
            </summary>
            <summary>
            A collection of extension methods for various default constraintTypes
            </summary>
            <summary>
            A collection of extension methods for various default types
            </summary>
            <summary>
            A collection of extension methods for various default types
            </summary>
            <summary>
            A collection of extension methods for various default types
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether a sequence is empty.
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="source"></param>
            <returns><see langword="true"/> if <paramref name="source"/> is empty. Otherwise <see langword="false"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.TakeRange``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            Returns a range of elements.
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="source"></param>
            <param name="startIndex">The inclusive starting index of the range.</param>
            <param name="count">The number of elements to take.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the requested range of the original <paramref name="source"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.TakeRange``1(System.Collections.Generic.IEnumerable{``0},System.Range)">
            <summary>
            Returns a range of elements.
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="source"></param>
            <param name="range">A <see cref="T:System.Range"/> to define the range of elements to be taken.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains the requested range of the original <paramref name="source"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds a range of items to the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.ICollection`1"/> to modify.</param>
            <param name="range">The items to add.</param>
            <returns>The original <see cref="T:System.Collections.Generic.IEnumerable`1"/> this method was invoked on to allow method chaining.</returns>
            <remarks>Although this method returns a <see cref="T:System.Collections.Generic.IEnumerable`1"/> it modifies the original collection. The value is only returned to enable method chaining.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="range"/> parameter is <see langword="null"/>.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.AddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Adds a <see cref="T:System.Collections.Generic.IDictionary`2"/> to the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IDictionary`2"/> to modify.</param>
            <param name="range">The <see cref="T:System.Collections.Generic.IDictionary`2"/> to add.</param>
            <returns>The original <see cref="T:System.Collections.Generic.IDictionary`2"/> this method was invoked on to allow method chaining.</returns>
            <remarks>Although this method returns a <see cref="T:System.Collections.Generic.IDictionary`2"/> it modifies the original collection. The value is only returned to enable method chaining.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="range"/> parameter is <see langword="null"/>.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.AddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Adds a range of <c>IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;</c> to the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IDictionary`2"/> to modify.</param>
            <param name="range">The <c>IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;</c>  to add.</param>
            <returns>The original <see cref="T:System.Collections.Generic.IDictionary`2"/> this method was invoked on to allow method chaining.</returns>
            <remarks>Although this method returns a <see cref="T:System.Collections.Generic.IDictionary`2"/> it modifies the original collection. The value is only returned to enable method chaining.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="range"/> parameter is <see langword="null"/>.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.AddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1}})">
            <summary>
            Adds a range of <c>IEnumerable&lt;(TKey Key,TValue Value)&gt;</c> to the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IDictionary`2"/> to modify.</param>
            <param name="range">The <c>IEnumerable&lt;(TKey Key,TValue Value&gt;&gt;</c>  to add.</param>
            <returns>The original <see cref="T:System.Collections.Generic.IDictionary`2"/> this method was invoked on to allow method chaining.</returns>
            <remarks>Although this method returns a <see cref="T:System.Collections.Generic.IDictionary`2"/> it modifies the original collection. The value is only returned to enable method chaining.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="range"/> parameter is <see langword="null"/>.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.LastOrDefaultInSorted``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            A non-cached version of <see cref="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/> for sorted collections.
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="source"></param>
            <param name="predicate">A delegate to test each element for a condition.</param>
            <returns>The last element in a sorted collection that satisfies the <paramref name="predicate"/> delegate or <c>null</c> if no such element was found.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <see langword="null"/>.</exception>    
            <remarks>The collection is expected to be sorted. Otherwise this method can yield unexpected results. The search will stop after the last consecutive match.<br/>
            While the standard <see cref="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/> iterates and caches the complete collection in order to produce a correct result for unsorted collections,
            <see cref="M:BionicCode.Utilities.Net.HelperExtensionsCommon.LastOrDefaultInSorted``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/> expects a sorted collection to avoid iterating the complete collection and therefore to significantly improve the performance in terms of speed and memory footprint.
            <para>The performance gain is only relevant if the collection is sorted in ascending order.</para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.LastInSorted``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            A non-cached version of <see cref="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/> for ascending sorted collections.
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="source"></param>
            <param name="predicate">A delegate to test each element for a condition.</param>
            <returns>The last element in a sorted collection that satisfies the <paramref name="predicate"/> delegate. If no such an element was found, a <see cref="T:System.InvalidOperationException"/> exception will be thrown.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="predicate"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The <paramref name="source"/> collection does not contain any element that satisfies the <paramref name="predicate"/> delegate.
            <para>The <paramref name="source"/> collection is empty.</para></exception>
            <remarks>The collection is expected to be sorted. Otherwise this method can yield unexpected results. The search will stop after the last consecutive match.<br/>
            While the standard <see cref="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/> iterates and caches the complete collection in order to produce a correct result for unsorted collections,
            <see cref="M:BionicCode.Utilities.Net.HelperExtensionsCommon.LastInSorted``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/> expects a sorted collection to avoid iterating the complete collection and therefore to significantly improve the performance in terms of speed and memory footprint. 
            <para>The performance gain is only relevant if the collection is sorted in ascending order.</para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.AddColumn``1(System.Data.DataTable,System.String)">
            <summary>
            Adds a new <see cref="T:System.Data.DataColumn"/> to a <see cref="T:System.Data.DataTable"/>.
            </summary>
            <typeparam name="TData">The data type of the column value.</typeparam>
            <param name="source">The <see cref="T:System.Data.DataTable"/> to add the new <see cref="T:System.Data.DataColumn"/> to.</param>
            <param name="columnName">The column's name.</param>
            <remarks>Added columns are initialized to the default value of <typeparamref name="TData"/> for all existing rows.
            <br/><see cref="M:BionicCode.Utilities.Net.HelperExtensionsCommon.AddColumn``1(System.Data.DataTable,System.String,System.Int32)"/> should be called before an overload of <see cref="M:BionicCode.Utilities.Net.HelperExtensionsCommon.AddRow(System.Data.DataTable,System.Object[])"/></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.AddColumn``1(System.Data.DataTable,System.String,System.Int32)">
            <summary>
            Adds a new <see cref="T:System.Data.DataColumn"/> to a <see cref="T:System.Data.DataTable"/>.
            </summary>
            <typeparam name="TData">The data type of the column value.</typeparam>
            <param name="source">The <see cref="T:System.Data.DataTable"/> to add the new <see cref="T:System.Data.DataColumn"/> to.</param>
            <param name="columnName">The column's name.</param>
            <param name="columnIndex">The explicit index of the created <see cref="T:System.Data.DataColumn"/>.</param>
            <remarks>If <paramref name="columnIndex"/> is less than 0 or greater than the existing number of columns - 1 (greater than the ordinal of the last column) then an Invalid <see cref="T:System.ArgumentException"/> is thrown.
            <para>Any columns between the previous and new ordinal will be renumbered, to adjust for a column's new ordinal.</para>
            Added columns are initialized to the default value of <typeparamref name="TData"/> for all existing rows.
            <br/><see cref="M:BionicCode.Utilities.Net.HelperExtensionsCommon.AddColumn``1(System.Data.DataTable,System.String,System.Int32)"/> should be called before an overload of <see cref="M:BionicCode.Utilities.Net.HelperExtensionsCommon.AddRow(System.Data.DataTable,System.Object[])"/></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.AddRow(System.Data.DataTable,System.Object[])">
            <summary>
            Adds a new <see cref="T:System.Data.DataRow"/> to a <see cref="T:System.Data.DataTable"/>.
            </summary>
            <param name="source">The <see cref="T:System.Data.DataTable"/> to add the new <see cref="T:System.Data.DataRow"/> to.</param>
            <param name="columnValues">The row's cell values ordered by column index.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.AddRow(System.Data.DataTable,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Adds a new <see cref="T:System.Data.DataRow"/> to a <see cref="T:System.Data.DataTable"/>.
            </summary>
            <param name="source">The <see cref="T:System.Data.DataTable"/> to add the new <see cref="T:System.Data.DataRow"/> to.</param>
            <param name="columnValues">The ordered row's cell values, where the item index maps to the column index.</param>
            <exception cref="T:System.IndexOutOfRangeException">When <paramref name="columnValues"/> contains less elements than <paramref name="source"/> has columns.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.AddRow(System.Data.DataTable,System.ValueTuple{System.Int32,System.Object}[])">
            <summary>
            Adds a new <see cref="T:System.Data.DataRow"/> to a <see cref="T:System.Data.DataTable"/>.
            </summary>
            <param name="source">The <see cref="T:System.Data.DataTable"/> to add the new <see cref="T:System.Data.DataRow"/> to.</param>
            <param name="columnValues">The row's cell values passed as tuples of <c>(int ColumnIndex, object ColumnValue)</c>.</param>
            <exception cref="T:System.IndexOutOfRangeException">When <paramref name="columnValues"/> contains less elements than <paramref name="source"/> has columns or a contained tuple has an invalid index.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToDisplayStringValue(BionicCode.Utilities.Net.AccessModifier,System.Boolean)">
            <summary>
            Converts the value of <see cref="T:BionicCode.Utilities.Net.AccessModifier"/> to a string representation.
            </summary>
            <param name="accessModifier"></param>
            <param name="toUpperCase">Controls whether to convert the string's first character to uppercase (<paramref name="toUpperCase"/>=<c>true</c>). The default is lowercase (<paramref name="toUpperCase"/>=<c>true</c>.</param>
            <returns>The readable string representation of the enum value.</returns>
            <exception cref="T:System.NotSupportedException">The enum value is not supported. (This exception is only intended for internal maintainance and will never be thrown in production code)</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToDisplayStringValue(BionicCode.Utilities.Net.ProfiledTargetType,System.Boolean)">
            <summary>
            Converts the value of <see cref="T:BionicCode.Utilities.Net.ProfiledTargetType"/> to a string representation.
            </summary>
            <param name="profiledTargetType"></param>
            <param name="toUpperCase">Controls whether to convert the string's first character to uppercase (<paramref name="toUpperCase"/>=<c>true</c>). The default is lowercase (<paramref name="toUpperCase"/>=<c>true</c>.</param>
            <returns>The readable string representation of the enum value.</returns>
            <exception cref="T:System.NotSupportedException">The enum value is not supported. (This exception is only intended for internal maintainance and will never be thrown in production code)</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToDisplayStringValue(BionicCode.Utilities.Net.TimeUnit,System.Boolean)">
            <summary>
            Converts the value of <see cref="T:BionicCode.Utilities.Net.TimeUnit"/> to a string representation.
            </summary>
            <param name="timeUnit"></param>
            <param name="toUpperCase">Controls whether to convert the string's first character to uppercase (<paramref name="toUpperCase"/>=<c>true</c>). The default is lowercase (<paramref name="toUpperCase"/>=<c>true</c>.</param>
            <returns>The readable string representation of the enum value.</returns>
            <exception cref="T:System.NotSupportedException">The enum value is not supported. (This exception is only intended for internal maintainance and will never be thrown in production code)</exception>
        </member>
        <member name="F:BionicCode.Utilities.Net.HelperExtensionsCommon.IndexerName">
            <summary>
            The property genericTypeParameterIdentifier of an indexer property. This genericTypeParameterIdentifier is compiler generated and equals the typeName of the <see langword="static"/>field <see cref="!:System.Windows.Data.Binding.IndexerName" />.
            </summary>
            <typeName>The generated property genericTypeParameterIdentifier of an indexer is <c>Item</c>.</typeName>
            <remarks>This field exists to enable writing of cross-platform compatible reflection code without the requirement to import the PresentationFramework.dll.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToFunc``1(System.Predicate{``0})">
            <summary>
            Converts a <see cref="T:System.Predicate`1"/> to a <see cref="T:System.Func`2"/>.
            </summary>
            <typeparam genericTypeParameterIdentifier="TParam">The parameter type for the predicate.</typeparam>
            <param genericTypeParameterIdentifier="predicate">The predicate to convert.</param>
            <returns>A <c>Func<typeparamref genericTypeParameterIdentifier="TParam"/>, bool></c> that returns the result of <paramref genericTypeParameterIdentifier="predicate"/>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToSignatureName(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Extension method to convert generic and non-generic member names to a readable full signature display genericTypeParameterIdentifier without the namespace.
            </summary>
            <param genericTypeParameterIdentifier="propertyInfo">The <see cref="T:System.Reflection.PropertyInfo"/> to extend.</param>
            <param genericTypeParameterIdentifier="isPropertyGet"><see langword="true"/> when the get() of the property should be used or <see langword="false"/> to use the set() method..</param>
            <returns>
            A readable genericTypeParameterIdentifier of type members, especially generic members. For example, <c>"Task.Run`1"</c> becomes <c>"Task.Run&lt;TResult&gt;"</c>.
            </returns>
            <remarks>
            Usually <see cref="P:System.Reflection.MemberInfo.Name"/> for generic members like <c>Task.Run&lt;TResult&gt;</c> would return <c>"Task.Run`1"</c>. 
            <br/>This helper unwraps the generic type parameters to construct the full signature genericTypeParameterIdentifier like <c>"public static Task&lt;TResult&gt; Task.Run&lt;TResult&gt;(Action action);"</c>.
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToSignatureShortName(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Extension method to convert generic and non-generic member names to a readable full signature display genericTypeParameterIdentifier without the namespace.
            </summary>
            <param genericTypeParameterIdentifier="propertyInfo">The <see cref="T:System.Reflection.PropertyInfo"/> to extend.</param>
            <param genericTypeParameterIdentifier="isPropertyGet"><see langword="true"/> when the get() of the property should be used or <see langword="false"/> to use the set() method..</param>
            <returns>
            A readable genericTypeParameterIdentifier of type members, especially generic members. For example, <c>"Task.Run`1"</c> becomes <c>"Task.Run&lt;TResult&gt;"</c>.
            </returns>
            <remarks>
            Usually <see cref="P:System.Reflection.MemberInfo.Name"/> for generic members like <c>Task.Run&lt;TResult&gt;</c> would return <c>"Task.Run`1"</c>. 
            <br/>This helper unwraps the generic type parameters to construct the full signature genericTypeParameterIdentifier like <c>"public static Task&lt;TResult&gt; Task.Run&lt;TResult&gt;(Action action);"</c>.
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.GetAccessModifier(System.Reflection.MemberInfo)">
            <summary>
            Gets the access modifier for <see cref="T:System.Reflection.MemberInfo"/> attributes like <see cref="T:System.Type"/>, <see cref="T:System.Reflection.MethodInfo"/>, <see cref="T:System.Reflection.ConstructorInfo"/>, <see cref="T:System.Reflection.PropertyInfo"/>, <see cref="T:System.Reflection.EventInfo"/> or <see cref="T:System.Reflection.FieldInfo"/>.
            </summary>
            <param genericTypeParameterIdentifier="type"></param>
            <returns>The <see cref="T:BionicCode.Utilities.Net.AccessModifier"/> for the current <paramref genericTypeParameterIdentifier="type"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Unable to identify the accessibility of the <paramref genericTypeParameterIdentifier="type"/>.</exception>
            <exception cref="T:System.NotSupportedException">The type provided by the <paramref genericTypeParameterIdentifier="type"/> is not supported.</exception>
            <remarks>For a <see cref="T:System.Reflection.PropertyInfo"/> the property accessors with the least restriction provides the access modifier for the property. This is a compiler rule.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToDisplayName(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Extension method to convert generic and non-generic member names to a readable display genericTypeParameterIdentifier without the namespace.
            </summary>
            <returns>
            A readable genericTypeParameterIdentifier of type members, especially generic members. For example, <c>"Task.Run`1"</c> becomes <c>"Task.Run&lt;TResult&gt;"</c>.
            </returns>
            <remarks>
            <para>Because <see cref="T:System.Type"/> derives from <see cref="T:System.Reflection.MemberInfo"/> this extension method also works on <see cref="T:System.Type"/>.</para>
            Usually <see cref="P:System.Reflection.MemberInfo.Name"/> for generic members like <c>"Task.Run&lt;TResult&gt;"</c> would return <c>"Task.Run`1"</c>. 
            <br/>This helper unwraps the generic type parameters to construct the full type genericTypeParameterIdentifier like <c>"Task.Run&lt;TResult&gt;"</c>.
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToFullDisplayName(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Extension method to convert generic and non-generic type names to a readable display genericTypeParameterIdentifier including the namespace.
            </summary>
            <returns>
            A readable genericTypeParameterIdentifier of type members, especially generic members. For example, <c>"Task.Run`1"</c> becomes <c>"System.Threading.Tasks.Task.Run&lt;TResult&gt;"</c>.
            </returns>
            <remarks>
            <para>Because <see cref="T:System.Type"/> derives from <see cref="T:System.Reflection.MemberInfo"/> this extension method also works on <see cref="T:System.Type"/>.</para>
            Usually <see cref="P:System.Reflection.MemberInfo.Name"/> for generic members like <c>"Task.Run&lt;TResult&gt;"</c> would return <c>"Task.Run`1"</c>. 
            <br/>This helper unwraps the generic type parameters to construct the full type genericTypeParameterIdentifier like <c>"System.Threading.Tasks.Task.Run&lt;TResult&gt;"</c>.
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToDisplayNameInternal(System.Reflection.MemberInfo,System.Boolean,System.Boolean)">
            <summary>
            Extension method to convert generic and non-generic type names to a readable display genericTypeParameterIdentifier including the namespace.
            </summary>
            <param genericTypeParameterIdentifier="memberInfo">The <see cref="T:System.Type"/> to extend.</param>
            <returns>
            A readable genericTypeParameterIdentifier of type members, especially generic members. For example, <c>"Task.Run`1"</c> becomes <c>"System.Threading.Tasks.Task.Run&lt;TResult&gt;"</c>.
            </returns>
            <remarks>
            <para>Because <see cref="T:System.Type"/> derives from <see cref="T:System.Reflection.MemberInfo"/> this extension method also works on <see cref="T:System.Type"/>.</para>
            Usually <see cref="P:System.Reflection.MemberInfo.Name"/> for generic members like <c>"Task.Run&lt;TResult&gt;"</c> would return <c>"Task.Run`1"</c>. 
            <br/>This helper unwraps the generic type parameters to construct the full type genericTypeParameterIdentifier like <c>"System.Threading.Tasks.Task.Run&lt;TResult&gt;"</c>.
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.IsAwaitable(System.Reflection.MethodInfo)">
            <summary>
            Checks if the provided <see cref="T:System.Reflection.MethodInfo"/> belongs to an asynchronous/awaitable method.
            </summary>
            <param genericTypeParameterIdentifier="methodInfo">The <see cref="T:System.Reflection.MethodInfo"/> to check if it belongs to an awaitable method.</param>
            <returns><see langword="true"/> if the associated method is awaitable. Otherwise <see langword="false"/>.</returns>
            <remarks>The method first checks if the return type is either <see cref="T:System.Threading.Tasks.Task"/> or <see cref="T:System.Threading.Tasks.ValueTask"/>. If that fails, it checks if the returned type (by compiler convention) exposes a "GetAwaiter" named method that returns an appropriate type (awaiter).
            <br/>If that fails too, it checks whether there exists any extension method named "GetAwaiter" for the returned type that would make the type awaitable. If this fails too, the method is not awaitable.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.IsStatic(System.Type)">
            <summary>
            Extension method to check if a <see cref="T:System.Type"/> is static.
            </summary>
            <param genericTypeParameterIdentifier="typeInfo">The extended <see cref="T:System.Type"/> instance.</param>
            <returns><see langword="true"/> if the <paramref genericTypeParameterIdentifier="typeInfo"/> is static. Otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.IsRef(System.Reflection.ParameterInfo)">
            <summary>
            Extension method to check if a <see cref="T:System.Reflection.ParameterInfo"/> represents a <see langword="ref"/> parameter.
            </summary>
            <returns><see langword="true"/> if the <paramref name="parameterInfo"/> represents a <see langword="ref"/> parameter. Otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.CanDeclareExtensionMethods(System.Type)">
            <summary>
            Extension method that checks if the provided <see cref="T:System.Type"/> is qualified to define extension methods.
            </summary>
            <param genericTypeParameterIdentifier="typeInfo">The extended <see cref="T:System.Type"/> instance.</param>
            <returns><see langword="true"/> if the <paramref genericTypeParameterIdentifier="typeInfo"/> is allowed to define extension methods. Otherwise <see langword="false"/>.</returns>
            <remarks>To be able to define extension methods a class must be static, non-generic, a top level type. 
            <br/>In addition this method checks if the declaring class and the method are both decorated with the <see cref="T:System.Runtime.CompilerServices.ExtensionAttribute"/> which is added by the compiler.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.IsExtensionMethod(System.Reflection.MethodInfo)">
            <summary>
            Extension method to check if a <see cref="T:System.Reflection.MethodInfo"/> is the info of an extension method.
            </summary>
            <param genericTypeParameterIdentifier="methodInfo">The extended <see cref="T:System.Reflection.MethodInfo"/> instance to validate.</param>
            <returns><see langword="true"/> if the <paramref genericTypeParameterIdentifier="methodInfo"/> is an extension method. Otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.IsExtensionMethodOf(System.Reflection.MethodInfo,System.Type)">
            <summary>
            Extension method to check if a <see cref="T:System.Reflection.MethodInfo"/> is the info of an extension method for a particular type.
            </summary>
            <param genericTypeParameterIdentifier="methodInfo">The extended <see cref="T:System.Reflection.MethodInfo"/> instance to validate.</param>
            <param genericTypeParameterIdentifier="typeToExtend">The <see cref="T:System.Type"/> the <paramref genericTypeParameterIdentifier="methodInfo"/> is expected to extend.</param>
            <returns><see langword="true"/> if the <paramref genericTypeParameterIdentifier="methodInfo"/> is an extension method for <paramref genericTypeParameterIdentifier="typeToExtend"/>. Otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToDataTable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a collection of objects to a <see cref="T:System.Data.DataTable"/>, where public property names are translated to column names.
            </summary>
            <typeparam name="TData">The type of the objects stored in the <paramref name="source"/> collection.</typeparam>
            <param name="source">The source collection to convert to a <see cref="T:System.Data.DataTable"/>.</param>
            <returns>A <see cref="T:System.Data.DataTable"/> created from <c>public</c> properties of the objects contained in the <paramref name="source"/>.</returns>
            <remarks>The extension method creates a <see cref="T:System.Data.DataTable"/> from the source object's <c>public</c> properties.
            <br/>Each public property is translated to a column where the property name is the column name.
            <br/>To control column naming, you can decorate the property with the <see cref="T:System.ComponentModel.DisplayNameAttribute"/> attribute to provide an alternative column name for the decorated property.
            <para>To exclude <c>public</c> properties from the conversion, decorate them with the <see cref="T:BionicCode.Utilities.Net.IgnoreAttribute"/> attribute.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToDictionary(System.Object)">
            <summary>
            Coverts any type to a <see cref="T:System.Collections.Generic.Dictionary`2"/>, where the <c>TKey</c> is the member name and <c>TValue</c> the member's value.
            </summary>
            <param name="instanceToConvert"></param>
            <returns>A <see cref="T:System.Collections.Generic.Dictionary`2"/>, where 
            <br/> 
            <list type="table">
            <listheader>
            <term><c>TKey</c> </term>
            <term><c>TValue</c> </term>
            </listheader>
            <item>
            <term>is the member's name of type <see cref="T:System.String"/> </term>
            <term>is the member's value of type <see cref="T:System.Object"/>, when the value is a primitive type like <see langword="int"/> or a <see cref="T:System.String"/></term>
            </item>
            <item>
            <term> </term>
            <term>is the member's value of type <see cref="T:System.Collections.Generic.Dictionary`2"/>, when the value is a complex type that itself was converted to a <c>Dictionary&lt;string, object&gt;</c></term>
            </item>
            </list>.
            <br/>This rules apply to the complete object graph.</returns>
            <remarks>This method recursivly traverses the complete object graph and converts every object node i.e. property value (execpt primitive types and <see cref="T:System.String"/>) to a <see cref="T:System.Collections.Generic.Dictionary`2"/>. 
            <br/>It creates entries for all <see langword="public"/> instance and class properties of this object. Each entry represents a property as key-value-pair of property name and property value.
            <para>To create a flat map of the object graph, use the <see cref="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToFlatDictionary(System.Object)"/></para>
            <para>Use the <see cref="T:BionicCode.Utilities.Net.IgnoreInObjectGraphAttribute"/> attribute to decorate properties that should be excluded.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToFlatDictionary(System.Object)">
            <summary>
            Coverts any type to a flattened <see cref="T:System.Collections.Generic.Dictionary`2"/>, where the <c>TKey</c> is the member's name and <c>TValue</c> the member's value.
            <br/>Flattened in this context means, only the object graph's root is converted.
            </summary>
            <param name="instanceToConvert"></param>
            <returns>A <see cref="T:System.Collections.Generic.Dictionary`2"/>, where 
            <br/> 
            <list type="table">
            <listheader>
            <term><c>TKey</c> </term>
            <term><c>TValue</c> </term>
            </listheader>
            <item>
            <term>is the member's name of type <see cref="T:System.String"/> </term>
            <term>is the member's value of type <see cref="T:System.Object"/></term>
            </item>
            </list>
            <br/>Since <see cref="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToFlatDictionary(System.Object)"/> returns a flat dictionary, the result graph has no depth.In other words, this rules apply to the root of the object graph.</returns>
            <remarks>This method only traverses the root of the object's graph and to convert it to a <see cref="T:System.Collections.Generic.Dictionary`2"/>. <br/>It creates entries for all <see langword="public"/> instance and class properties of this object. Each entry represents a property as key-value-pair of property name (of type <see cref="T:System.String"/>) and property value (of type <see cref="T:System.Object"/>).    
            <para>To traverse the complete object graph recursively (to convert every object node i.e. property value to a <see cref="T:System.Collections.Generic.Dictionary`2"/>), use the <see cref="M:BionicCode.Utilities.Net.HelperExtensionsCommon.ToDictionary(System.Object)"/> method.</para>
            <para>Use the <see cref="T:BionicCode.Utilities.Net.IgnoreInObjectGraphAttribute"/> attribute to decorate properties that should be excluded.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.HelperExtensionsCommon.HasReachedEnd(System.IO.Stream)">
            <summary>
            Return whether the end of a <see cref="T:System.IO.Stream"/> is reached.
            </summary>
            <param name="streamToCheck"></param>
            <returns></returns>
        </member>
        <member name="T:BionicCode.Utilities.Net.FactoryMode">
            <summary>
            Describes lifetime scope of object instances
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FactoryMode.Default">
            <summary>
            Unset
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FactoryMode.Singleton">
            <summary>
            Create a shared instance
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FactoryMode.Transient">
            <summary>
            A new instance is created for each request
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FactoryMode.Scoped">
            <summary>
            Create an instance that is shared iside a particular scope
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1">
            <summary>
            A reusable command that encapsulates the implementation of <see cref="T:System.Windows.Input.ICommand"/> with support for async/await command delegates. 
            <br/>Enables instant creation of an ICommand without implementing the ICommand interface for each command.
            The <see cref="T:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1"/> accepts asynchronous command handlers and supports data binding to properties like <see cref="P:BionicCode.Utilities.Net.AsyncRelayCommandCore.IsExecuting"/> by implementing <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>.
            <br/>Call and await the <see cref="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.ExecuteAsync(`0)"/> method or one of its overloads to execute the command explicitly asynchronously.
              <seealso cref="T:System.Windows.Input.ICommand" />
            </summary>
            <remarks><c>AsyncRelayCommandCommon</c> implements <see cref="T:System.Windows.Input.ICommand" />. In case the <see cref="T:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1"/> is executed explicitly, especially with an asynchronous command handler registered, it is highly recommended to invoke the awaitable <see cref="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon.ExecuteAsync"/> or its overloads instead.</remarks>
        </member>
        <member name="F:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.executeCancellableAsyncDelegate">
            <summary>
            The registered async execute delegate that supports cancellation and accepts a parameter of <typeparamref name="TParam"/>.
            </summary>
            <value>
            A delegate that supports cancellation and takes a command parameter of <typeparamref name="TParam"/> and returns a <see cref="T:System.Threading.Tasks.Task"/>.</value>
        </member>
        <member name="F:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.executeCancellableDelegate">
            <summary>
            The registered execute delegate that accepts a parameter of <typeparamref name="TParam"/>.
            </summary>
            <value>
            A delegate that supports cancellation and takes a command parameter of <typeparamref name="TParam"/> and returns a <see cref="T:System.Threading.Tasks.Task"/>.</value>
        </member>
        <member name="F:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.canExecuteDelegate">
            <summary>
            The registered CanExecute delegate that accepts a parameter of <typeparamref name="TParam"/>.
            </summary>
            <value>
            <c>true</c> if the command can execute, otherwise <c>false</c>.</value>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.#ctor(System.Action{`0})">
            <summary>
              Creates a new synchronous command that can always execute (<see cref="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.CanExecute(`0)"/> will always return <c>true</c>)
              <br/> and accepts a command parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="execute">The execute handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.#ctor(System.Action{`0,System.Threading.CancellationToken})">
            <summary>
              Creates a new synchronous command that can always execute (<see cref="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.CanExecute(`0)"/> will always return <c>true</c>) 
              <br/>and accepts a command parameter of type <typeparamref name="TParam"/>
              <br/>and supports cancellation.
            </summary>
            <param name="execute">The execute handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.#ctor(System.Func{`0,System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>
              Creates a new asynchronous command that can always execute (<see cref="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.CanExecute(`0)"/> will always return <c>true</c>) 
              <br/>and that accepts a command parameter of type <typeparamref name="TParam"/>
              <br/>and supports cancellation.
            </summary>
            <param name="executeAsync">The awaitable execute handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.#ctor(System.Func{`0,System.Threading.Tasks.Task})">
            <summary>
              Creates a new asynchronous command that can always execute (<see cref="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.CanExecute(`0)"/> will always return <c>true</c>) 
              <br/>and that accepts a command parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="executeAsync">The awaitable execute handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.#ctor(System.Action{`0},System.Predicate{`0})">
            <summary>
              Creates a new synchronous command that accepts a command parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="execute">The execute handler.</param>
            <param name="canExecute">The can execute handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.#ctor(System.Func{`0,System.Threading.Tasks.Task},System.Predicate{`0})">
            <summary>
              Creates a new asynchronous command that accepts a command parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="executeAsync">The awaitable execute handler.</param>
            <param name="canExecute">The can execute handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.#ctor(System.Func{`0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Predicate{`0})">
            <summary>
              Creates a new asynchronous command that supports cancellation and accepts a command parameter of <typeparamref name="TParam"/>.
            </summary>
            <param name="executeAsync">The awaitable execute handler.</param>
            <param name="canExecute">The can execute handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.#ctor(System.Action{`0,System.Threading.CancellationToken},System.Predicate{`0})">
            <summary>
              Creates a new synchronous command that supports cancellation and accepts a command parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="execute">The execute handler.</param>
            <param name="canExecute">The can execute handler.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.CanExecute(`0)">
            <summary>
              Determines whether this AsyncRelayCommandCommon can execute.
            </summary>
            <param name="parameter">
              Data used by the command. 
            </param>
            <returns><c>true</c> if this command can be executed, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.ExecuteAsync(`0)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.ExecuteAsync(`0,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.ExecuteAsync(`0,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.ExecuteAsync(`0,System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncRelayCommandCommon`1.System#Windows#Input#ICommand#Execute(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:BionicCode.Utilities.Net.Factory`1">
             <summary>
             Provides a base class of <see cref="T:BionicCode.Utilities.Net.IFactory`1"/> that supports lifetime management using scopes and <see cref="P:BionicCode.Utilities.Net.Factory`1.FactoryMode"/>.
             </summary>
             <typeparam name="TObject">The type of the instance to create.</typeparam>
             <remarks>
             <para>This base class is provided to make it easier for implementers of <see cref="T:BionicCode.Utilities.Net.IFactory`1"/> to create a custom factory. Implementers are encouraged to extend this base class instead of creating their own.
             <br/><see cref="T:BionicCode.Utilities.Net.Factory`1"/> provides useful features like factory scopes and other lifetime managment modes like shared instances.</para>
             <para>The internals will handle the lifetime management based on the value of the <see cref="P:BionicCode.Utilities.Net.Factory`1.FactoryMode"/> property. To control instantiation of the factory products, simply implement the abstract <see cref="M:BionicCode.Utilities.Net.Factory`1.CreateInstance"/> and <see cref="M:BionicCode.Utilities.Net.Factory`1.CreateInstance(System.Object[])"/> members.</para>
             </remarks>
             <example>
             The following example shows how to implement an <see cref="T:BionicCode.Utilities.Net.IFactory`1"/> by extending the anstract <see cref="T:BionicCode.Utilities.Net.Factory`1"/> clas.
             <br/>It also shows how to create and use a factory scope.
             <code>
            public class PersonFactoryExample
            {
              PersonFactory PersonFactory { get; }
              public FactoryTest()
              {
                this.PersonFactory = new PersonFactory();
              }
              
              public void FactoryExample()
              {
                // Configure factory to produce shared instances
                this.PersonFactory.FactoryMode = FactoryMode.Singleton;
                
                Person firstSharedInstanceInScope = null;
                Person secondSharedInstanceInScope = null;
                Person sharedInstanceCreatedBeforeScope = this.PersonFactory.Create();
                
                // Create a new factory scope
                using (IDisposable factoryScope = this.PersonFactory.CreateScope())
                {
                  firstSharedInstanceInScope = this.PersonFactory.Create();
                  secondSharedInstanceInScope = this.PersonFactory.Create();
                }
                
                Person sharedInstanceCreatedAfterScope = this.PersonFactory.Create();
                  
                bool isReferenceEqual = ReferenceEquals(firstSharedInstanceInScope, secondShartedInstanceInScope); // true
                isReferenceEqual = ReferenceEquals(firstSharedInstanceInScope, sharedInstanceCreatedBeforeScope); // false
                isReferenceEqual = ReferenceEquals(secondSharedInstanceInScope, sharedInstanceCreatedBeforeScope); // false
                isReferenceEqual = ReferenceEquals(firstSharedInstanceInScope, sharedInstanceCreatedAfterScope); // false
                isReferenceEqual = ReferenceEquals(secondSharedInstanceInScope, sharedInstanceCreatedAfterScope); // false
                isReferenceEqual = ReferenceEquals(sharedInstanceCreatedBeforeScope, sharedInstanceCreatedAfterScope); // true
                
                // Configure factory to produce transient instances
                this.PersonFactory.FactoryMode = FactoryMode.Transient;
                
                Person firstTransientInstance = this.PersonFactory.Create();
                Person secondTransientInstance = this.PersonFactory.Create();
                
                isReferenceEqual = ReferenceEquals(firstTransientInstance, secondTransientInstance); // false
              }
            }
            
            public class PersonFactory : Factory{Person}
            {
              protected override Person CreateInstance() 
                => new Person("DefaultPersonFirstName", "DefaultPersonLastName", -1);
                
              protected override Person CreateInstance(params object[] args) 
                => new Person(args[0] as string, args[1] as string, (int)args[2]);
            }
            
            public class Person
            {
              public Person(string firstName, string lastName, int id)
              {
                this.FirstName = firstName;
                this.LastName = lastName;
                this.Id = id;
              }
              
              public string FirstName { get; }
              public string LastName { get; }
              public int Id { get; }
            }
             </code>
             </example>
        </member>
        <member name="M:BionicCode.Utilities.Net.Factory`1.#ctor">
            <summary>
            Initializes the <c>Factory</c> to create instances using <see cref="F:BionicCode.Utilities.Net.FactoryMode.Singleton"/>. 
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.Factory`1.#ctor(BionicCode.Utilities.Net.FactoryMode)">
            <summary>
            Initializes instance. 
            </summary>
            <param name="factoryMode">Describes the created objects lifetime using <see cref="P:BionicCode.Utilities.Net.Factory`1.FactoryMode"/>.</param>
        </member>
        <member name="P:BionicCode.Utilities.Net.Factory`1.SharedProductInstance">
            <summary>
            The shared instance which <see cref="T:BionicCode.Utilities.Net.Factory`1"/> returns when <see cref="P:BionicCode.Utilities.Net.Factory`1.FactoryMode"/>
            is set to <see cref="F:BionicCode.Utilities.Net.FactoryMode.Singleton"/> or <see cref="F:BionicCode.Utilities.Net.FactoryMode.Scoped"/>.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.Factory`1.FactoryMode">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.Factory`1.Create">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.Factory`1.Create(System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.Factory`1.CreateScope">
             <summary>
             Creates a scope in which created instances of the current <see cref="T:BionicCode.Utilities.Net.Factory`1"/> are shared instances.
             </summary>
             <returns>An <see cref="T:System.IDisposable"/> to define the scope.</returns>
             <remarks>The instances returned from the current <see cref="T:BionicCode.Utilities.Net.Factory`1"/> instance are shared instances within this scope.
             <br/>This means the returned instances are the same whithin the current scope, but different from the enclosing scope.
             <para>To define the scope, simply call <see cref="M:BionicCode.Utilities.Net.Factory`1.CreateScope"/> and wrap the returned <see cref="T:System.IDisposable"/> inside a <see langword="using"/> statement or expression.</para></remarks>
             <example>
             The following example shows how to create a factory scope. See <see cref="T:BionicCode.Utilities.Net.Factory`1"/> for the complete example.
             <code>
            public class PersonFactoryExample
            {
              PersonFactory PersonFactory { get; }
              public FactoryTest()
              {
                this.PersonFactory = new PersonFactory();
              }
              
              public void FactoryExample()
              {
                // Configure factory to produce shared instances
                this.PersonFactory.FactoryMode = FactoryMode.Singleton;
                
                Person firstSharedInstanceInScope = null;
                Person secondSharedInstanceInScope = null;
                Person sharedInstanceCreatedBeforeScope = this.PersonFactory.Create();
                
                // Create a new factory scope
                using (IDisposable factoryScope = this.PersonFactory.CreateScope())
                {
                  firstSharedInstanceInScope = this.PersonFactory.Create();
                  secondSharedInstanceInScope = this.PersonFactory.Create();
                }
                
                Person sharedInstanceCreatedAfterScope = this.PersonFactory.Create();
                  
                bool isReferenceEqual = ReferenceEquals(firstSharedInstanceInScope, secondShartedInstanceInScope); // true
                isReferenceEqual = ReferenceEquals(firstSharedInstanceInScope, sharedInstanceCreatedBeforeScope); // false
                isReferenceEqual = ReferenceEquals(secondSharedInstanceInScope, sharedInstanceCreatedBeforeScope); // false
                isReferenceEqual = ReferenceEquals(firstSharedInstanceInScope, sharedInstanceCreatedAfterScope); // false
                isReferenceEqual = ReferenceEquals(secondSharedInstanceInScope, sharedInstanceCreatedAfterScope); // false
                isReferenceEqual = ReferenceEquals(sharedInstanceCreatedBeforeScope, sharedInstanceCreatedAfterScope); // true
                
                // Configure factory to produce transient instances
                this.PersonFactory.FactoryMode = FactoryMode.Transient;
                
                Person firstTransientInstance = this.PersonFactory.Create();
                Person secondTransientInstance = this.PersonFactory.Create();
                
                isReferenceEqual = ReferenceEquals(firstTransientInstance, secondTransientInstance); // false
              }
            }
             </code>
             </example>
        </member>
        <member name="M:BionicCode.Utilities.Net.Factory`1.CreateInstance">
            <summary>
            Implementation to create and initialize instances of type <typeparamref name="TObject"/>.
            </summary>
            <returns>An instance of type <typeparamref name="TObject"/>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.Factory`1.CreateInstance(System.Object[])">
            <summary>
            Implementation to create and initialize instances of type <typeparamref name="TObject"/>.
            </summary>
            <returns>An instance of type <typeparamref name="TObject"/>.</returns>
            <param name="args">A variable list of arguments.</param>
        </member>
        <member name="T:BionicCode.Utilities.Net.IAsyncRelayCommandCommon`1">
            <summary>
            An interface to define a reusable command that encapsulates the implementation of <see cref="T:System.Windows.Input.ICommand"/> with support for async/await command delegates and data binding (implements <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>). 
            <br/>Enables instant creation of an ICommand without implementing the ICommand interface for each command.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCommon`1.CanExecute(`0)">
            <summary>
            Checks if the <see cref="T:System.Windows.Input.ICommand"/> can execute based on the command parameter.
            </summary>
            <param name="parameter">The command parameter.</param>
            <returns><c>true</c> when the <see cref="T:System.Windows.Input.ICommand"/> can execute, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCommon`1.ExecuteAsync(`0)">
            <summary>
              Executes the AsyncRelayCommand on the current command target asynchronously.
            </summary>
            <param name="parameter">
              Data used by the command. If the command does not require data to be passed,
              this object can be set to null.
            </param>
            <remarks>If the registered command handler is asynchronous (awaitable), then the execution is asynchronous otherwise the delegate is executed synchronously.  
            </remarks>
            <exception cref="T:System.OperationCanceledException">If the executing command delegate was cancelled.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCommon`1.ExecuteAsync(`0,System.Threading.CancellationToken)">
            <summary>
              Executes the AsyncRelayCommand on the current command target asynchronously.
            </summary>
            <param name="parameter">
              Data used by the command. If the command does not require data to be passed,
              this object can be set to null.
            </param>
            <param name="cancellationToken">An instance of <seealso cref="T:System.Threading.CancellationToken"/> to cancel the executing command delegate.</param>
            <remarks>If the registered command handler is asynchronous (awaitable), then the execution is asynchronous otherwise the delegate is executed synchronously.  
            </remarks>
            <exception cref="T:System.OperationCanceledException">If the executing command delegate was cancelled.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCommon`1.ExecuteAsync(`0,System.TimeSpan)">
            <summary>
              Executes the AsyncRelayCommand on the current command target asynchronously.
            </summary>
            <param name="parameter">
              Data used by the command. If the command does not require data to be passed,
              this object can be set to null.
            </param>
            <param name="timeout">A <seealso cref="T:System.TimeSpan"/> to specify the timeout of the operation. 
            <br/>A value of <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> (or a <see cref="T:System.TimeSpan"/> that represents -1) will specifiy an infinite time out. 
            <br/>A value of <see cref="F:System.TimeSpan.Zero"/> will cancel the operation immediately.</param>
            <remarks>If the registered command handler is asynchronous (awaitable), then the execution is asynchronous otherwise the delegate is executed synchronously.  
            </remarks>
            <exception cref="T:System.OperationCanceledException">If the executing command delegate was cancelled.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout>>"/>.<see cref="P:System.TimeSpan.TotalMilliseconds"/> is less than -1 or greater than <see cref="F:System.Int32.MaxValue"/> (or <see cref="F:System.UInt32.MaxValue"/> - 1 on some versions of .NET). 
            <br/>Note that this upper bound is more restrictive than <see cref="F:System.TimeSpan.MaxValue"/>.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCommon`1.ExecuteAsync(`0,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
              Executes the AsyncRelayCommand on the current command target asynchronously.
            </summary>
            <param name="parameter">
              Data used by the command. If the command does not require data to be passed,
              this object can be set to null.
            </param>
            <param name="timeout">A <seealso cref="T:System.TimeSpan"/> to specify the timeout of the operation. 
            <br/>A value of <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> (or a <see cref="T:System.TimeSpan"/> that represents -1) will specifiy an infinite time out. 
            <br/>A value of <see cref="F:System.TimeSpan.Zero"/> will cancel the operation immediately.</param>
            <param name="cancellationToken">An instance of <seealso cref="T:System.Threading.CancellationToken"/> to cancel the executing command delegate.</param>
            <remarks>If the registered command handler is asynchronous (awaitable), then the execution is asynchronous otherwise the delegate is executed synchronously.  
            </remarks>
            <exception cref="T:System.OperationCanceledException">If the executing command delegate was cancelled.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout>>"/>.TotalMilliseconds is less than -1 or greater than <see cref="F:System.Int32.MaxValue"/> (or <see cref="F:System.UInt32.MaxValue"/> - 1 on some versions of .NET). Note that this upper bound is more restrictive than <see cref="F:System.TimeSpan.MaxValue"/>.</exception>
        </member>
        <member name="T:BionicCode.Utilities.Net.IFactory`1">
            <summary>
            Interface to implement Abstract Factory pattern.
            <para>Implementers are encouraged to extend the abstract <see cref="T:BionicCode.Utilities.Net.Factory`1"/> class instead of creating their own.</para>
            </summary>
            <typeparam name="TCreate">The type of the instantiated object.</typeparam>
        </member>
        <member name="M:BionicCode.Utilities.Net.IFactory`1.Create">
            <summary>
            Creates the instance.
            </summary>
            <returns>An instance of <typeparamref name="TCreate"/>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IFactory`1.Create(System.Object[])">
            <summary>
            Creates the instance, allowing arguments.
            </summary>
            <param name="args">The arguments for the factory to use to instantiate the type.</param>
            <returns>An instance of <typeparamref name="TCreate"/>.</returns>
        </member>
        <member name="P:BionicCode.Utilities.Net.IFactory`1.FactoryMode">
            <summary>
            Configures the lifetime scope of the created object instances.
            Default is <see cref="F:BionicCode.Utilities.Net.FactoryMode.Singleton"/>
            </summary>
            <value>The lifetime scope  <see cref="F:BionicCode.Utilities.Net.FactoryMode.Singleton"/> of the created object instances</value>
        </member>
        <member name="T:BionicCode.Utilities.Net.NullObjectFactory`1">
            <summary>
            Implementation of <see cref="T:BionicCode.Utilities.Net.INullObject"/> and <see cref="T:BionicCode.Utilities.Net.IFactory`1"/>. Used to create an instance of a <see cref="T:BionicCode.Utilities.Net.INullObject"/> where <see cref="P:BionicCode.Utilities.Net.INullObject.IsNull"/> is set to <c>true</c> by default.
            </summary>
            <typeparam name="TObject"></typeparam>
        </member>
        <member name="M:BionicCode.Utilities.Net.NullObjectFactory`1.#ctor(System.Func{`0})">
            <summary>
            Initializes the <see cref="T:BionicCode.Utilities.Net.NullObjectFactory`1"/> using a factory method delegate using <see cref="F:BionicCode.Utilities.Net.FactoryMode.Singleton"/>.
            </summary>
            <param name="factoryMethod">The delegate to create instances of type <typeparamref name="TObject"/>.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.NullObjectFactory`1.#ctor(System.Func{`0},BionicCode.Utilities.Net.FactoryMode)">
            <summary>
            Initializes the <see cref="T:BionicCode.Utilities.Net.NullObjectFactory`1"/> using a factory method delegate using <see cref="F:BionicCode.Utilities.Net.FactoryMode.Singleton"/>.
            </summary>
            <param name="factoryMethod">The delegate to create instances of type <typeparamref name="TObject"/>.</param>
            <param name="factoryMode">The lifetime scope of the created instance.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.NullObjectFactory`1.#ctor(BionicCode.Utilities.Net.IFactory{`0})">
            <summary>
            Initializes the <see cref="T:BionicCode.Utilities.Net.NullObjectFactory`1"/> using a <see cref="T:BionicCode.Utilities.Net.IFactory`1"/> and its <see cref="P:BionicCode.Utilities.Net.IFactory`1.FactoryMode"/> to set the <see cref="T:BionicCode.Utilities.Net.FactoryMode"/>.
            </summary>
            <param name="factory">The <see cref="T:BionicCode.Utilities.Net.IFactory`1"/> to create instances of type <typeparamref name="TObject"/>.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.NullObjectFactory`1.CreateInstance">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.NullObjectFactory`1.CreateInstance(System.Object[])">
            <inheritdoc />
        </member>
        <member name="T:BionicCode.Utilities.Net.ValueChangedEventArgs`1">
            <summary>
            Generic EventArgs implementation that supports value changed information
            by holding the old and the new value.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="M:BionicCode.Utilities.Net.ValueChangedEventArgs`1.#ctor(`0,`0)">
            <summary>
            Constructor
            </summary>
            <param name="newValue">The new value that replaces the old value.</param>
            <param name="oldValue">The old value that was replaced by the new value.</param>
        </member>
        <member name="P:BionicCode.Utilities.Net.ValueChangedEventArgs`1.NewValue">
            <summary>
            The new value after the change.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.ValueChangedEventArgs`1.OldValue">
            <summary>
            The old value before the change.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.ValueEventArgs`1">
            <summary>
            Generic EventArgs implementation that supports to store a value.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="M:BionicCode.Utilities.Net.ValueEventArgs`1.#ctor(`0)">
            <summary>
            Constructor.
            </summary>
            <param name="value">The value to send as event args.</param>
        </member>
        <member name="P:BionicCode.Utilities.Net.ValueEventArgs`1.Value">
            <summary>
            The value to send as event args.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.IAsyncRelayCommandCommon">
            <summary>
            An interface to define a reusable command that encapsulates the implementation of <see cref="T:System.Windows.Input.ICommand"/> with support for async/await command delegates and data binding (implements <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>). 
            <br/>Enables instant creation of an ICommand without implementing the ICommand interface for each command.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCommon.CanExecute">
            <summary>
            Checks if the <see cref="T:System.Windows.Input.ICommand"/> can execute.
            </summary>
            <returns><c>true</c> when the <see cref="T:System.Windows.Input.ICommand"/> can execute, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCommon.ExecuteAsync">
            <summary>
              Executes the AsyncRelayCommand on the current command target asynchronously.
            </summary>
            <remarks>If the registered command handler is asynchronous (awaitable), then the execution is asynchronous otherwise the delegate is executed synchronously.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCommon.ExecuteAsync(System.Threading.CancellationToken)">
            <summary>
              Executes the AsyncRelayCommand on the current command target asynchronously.
            </summary>
            <param name="cancellationToken">An instance of <seealso cref="T:System.Threading.CancellationToken"/> to cancel the executing command delegate.</param>
            <remarks>If the registered command handler is asynchronous (awaitable), then the execution is asynchronous otherwise the delegate is executed synchronously.
            <para>Only one command is executed at time. Sucessive command invocations are enqueued and run after the currently executing delegate has completed
            <br/> or was cancelled. Query <see cref="P:BionicCode.Utilities.Net.IAsyncRelayCommandCore.HasPending"/> to know if the command has pending delegate executions and <see cref="!:PendingCount"/> to knwo the number of pending delegate executions.</para>
            </remarks>
            <exception cref="T:System.OperationCanceledException">If executing command delegate was cancelled.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCommon.ExecuteAsync(System.TimeSpan)">
            <summary>
              Executes the AsyncRelayCommand on the current command target asynchronously.
            </summary>
            <param name="timeout">A <seealso cref="T:System.TimeSpan"/> to specify the timeout of the operation. 
            <br/>A value of <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> (or a <see cref="T:System.TimeSpan"/> that represents -1) will specifiy an infinite time out. 
            <br/>A value of <see cref="F:System.TimeSpan.Zero"/> will cancel the operation immediately.</param>
            <remarks>If the registered command handler is asynchronous (awaitable), then the execution is asynchronous otherwise the delegate is executed synchronously.  
            <para>Only one command is executed at time. Sucessive command invocations are enqueued and run after the currently executing delegate has completed
            <br/> or was cancelled. Query <see cref="P:BionicCode.Utilities.Net.IAsyncRelayCommandCore.HasPending"/> to know if the command has pending delegate executions and <see cref="!:PendingCount"/> to knwo the number of pending delegate executions.</para>
            </remarks>
            <exception cref="T:System.OperationCanceledException">If the executing command delegate was cancelled.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCommon.ExecuteAsync(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
              Executes the AsyncRelayCommand on the current command target asynchronously.
            </summary>
            <param name="timeout">A <seealso cref="T:System.TimeSpan"/> to specify the timeout of the operation. 
            <br/>A value of <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> (or a <see cref="T:System.TimeSpan"/> that represents -1) will specifiy an infinite time out. 
            <br/>A value of <see cref="F:System.TimeSpan.Zero"/> will cancel the operation immediately.</param>
            <param name="cancellationToken">An instance of <seealso cref="T:System.Threading.CancellationToken"/> to cancel the executing command delegate.</param>
            <remarks>If the registered command handler is asynchronous (awaitable), then the execution is asynchronous otherwise the delegate is executed synchronously.  
            </remarks>
            <exception cref="T:System.OperationCanceledException">If the executing command delegate was cancelled.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout>>"/>.TotalMilliseconds is less than -1 or greater than <see cref="F:System.Int32.MaxValue"/> (or <see cref="F:System.UInt32.MaxValue"/> - 1 on some versions of .NET). Note that this upper bound is more restrictive than <see cref="F:System.TimeSpan.MaxValue"/>.</exception>
        </member>
        <member name="T:BionicCode.Utilities.Net.IAsyncRelayCommandCore">
            <summary>
            Defines the shared core functionality of the different implementations.
            </summary>
        </member>
        <member name="E:BionicCode.Utilities.Net.IAsyncRelayCommandCore.PendingCommandCancelled">
            <summary>
            Event is raised after a pending command has been cancelled.
            </summary>
        </member>
        <member name="E:BionicCode.Utilities.Net.IAsyncRelayCommandCore.ExecutingCommandCancelled">
            <summary>
            Event is raised if the executing command handler has been cancelled.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.IAsyncRelayCommandCore.IsExecuting">
            <summary>
            A flag to signal if the asynchronous operation has completed.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.IAsyncRelayCommandCore.CanBeCanceled">
            <summary>
            Returns whether the command can be cancelled.
            </summary>
            <value><c>true</c> if cancellation is allowed. Otherwise <c>false</c>.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.IAsyncRelayCommandCore.IsCancelled">
            <summary>
            Returns whether the command's executing operation was cancelled.
            </summary>
            <value><c>true</c> if the last command execution was cancelled. Otherwise <c>false</c>.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.IAsyncRelayCommandCore.HasPending">
            <summary>
            Return whether the command has pending executions.
            </summary>
            <remarks>Only one command is executed at time. Sucessive command invocations are enqueued and run after the currently executing delegate has completed
            <br/> or was cancelled.</remarks>
        </member>
        <member name="P:BionicCode.Utilities.Net.IAsyncRelayCommandCore.PendingCount">
            <summary>
            Returns the number of pending command delegate executions.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.IAsyncRelayCommandCore.CurrentCancellationToken">
            <summary>
            The currently used <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <value>A <see cref="T:System.Threading.CancellationToken"/> instance currently in use during the command execution.</value>
            <remarks>This property can be used to query the state of the cancellation or to register a cancellation callback by calling <see cref="M:System.Threading.CancellationToken.Register(System.Action)"/>.
            <br/>The instance will change for each command execution.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCore.CancelAll">
            <summary>
            Cancels all pending and executing commands.
            </summary>
            <remarks>See <see cref="M:System.Threading.CancellationTokenSource.Cancel"/> for the exception behavior of this overload.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCore.CancelAll(System.Boolean)">
            <summary>
            Cancels all pending and executing commands.
            </summary>
            <param name="throwOnFirstException">See <see cref="M:System.Threading.CancellationTokenSource.Cancel(System.Boolean)"/> for the effects of the parameter.</param>
            <remarks>See <see cref="M:System.Threading.CancellationTokenSource.Cancel(System.Boolean)"/> for the exception behavior of this overload.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCore.CancelExecuting">
            <summary>
            Cancels the currently executing command.
            </summary>
            <remarks>See <see cref="M:System.Threading.CancellationTokenSource.Cancel"/> for the exception behavior of this overload.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCore.CancelExecuting(System.Boolean)">
            <summary>
            Cancels the currently executing command.
            </summary>
            <param name="throwOnFirstException">See <see cref="M:System.Threading.CancellationTokenSource.Cancel(System.Boolean)"/> for the effects of the parameter.</param>
            <remarks>See <see cref="M:System.Threading.CancellationTokenSource.Cancel(System.Boolean)"/> for the exception behavior of this overload.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCore.CancelPending">
            <summary>
            Cancels all pending command executions.
            </summary>    
            <remarks>See <see cref="M:System.Threading.CancellationTokenSource.Cancel"/> for the exception behavior of this overload.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCore.CancelPending(System.Boolean)">
            <summary>
            Cancels all pending command executions.
            </summary>    
            <param name="throwOnFirstException">See <see cref="M:System.Threading.CancellationTokenSource.Cancel(System.Boolean)"/> for the effects of the parameter.</param>
            <remarks>See <see cref="M:System.Threading.CancellationTokenSource.Cancel(System.Boolean)"/> for the exception behavior of this overload.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.IAsyncRelayCommandCore.InvalidateCommand">
            <summary>
            Raises the <seealso cref="E:System.Windows.Input.ICommand.CanExecuteChanged"/> event of this particular command only.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.IEventAggregator">
            <summary>
            Allows listening to events without introducing direct coupling between observer and observable. The observer can handle events withou introducing a dependency to the event source.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterObservable(System.Object,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Register a type as event source.
            </summary>
            <param name="eventSource">The publisher instance.</param>
            <param name="eventNames">A collection of event names that define the observed events of the <paramref name="eventSource"/></param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterObserver(System.String,System.Type,System.Delegate)">
            <summary>
            Registers an event delegate to handle a specific event published by a specific observable type.
            </summary>
            <param name="eventName">The name of the observed event.</param>
            <param name="eventSourceType">The type of the observable.</param>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterObserver(System.String,System.Type,System.Delegate,System.Boolean)">
            <summary>
            Registers an event delegate to handle a specific event published by a specific observable type.
            </summary>
            <param name="eventName">The name of the observed event.</param>
            <param name="eventSourceType">The type of the observable.</param>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <param name="isMarshalEventToCurrentThreadEnabled"><c>true</c> if the current <see cref="T:System.Threading.SynchronizationContext"/> should be captured to execute the event handler.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterObserver(System.String,System.Type,System.Delegate,System.Threading.SynchronizationContext)">
            <summary>
            Registers an event delegate to handle a specific event published by a specific observable type.
            </summary>
            <param name="eventName">The name of the observed event.</param>
            <param name="eventSourceType">The type of the observable.</param>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <param name="synchronizationContext">The <see cref="T:System.Threading.SynchronizationContext"/> that the event delegate is to be executed on.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterObserver``1(System.String,System.Type,System.EventHandler{``0})">
            <summary>
            Registers an event delegate to handle a specific event published by a specific observable type.
            </summary>
            <typeparam name="TEventArgs">The type of the event args object.</typeparam>
            <param name="eventName">The name of the observed event.</param>
            <param name="eventSourceType">The type of the observable.</param>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterObserver``1(System.String,System.Type,System.EventHandler{``0},System.Boolean)">
            <summary>
            Registers an event delegate to handle a specific event published by a specific observable type.
            </summary>
            <typeparam name="TEventArgs">The type of the event args object.</typeparam>
            <param name="eventName">The name of the observed event.</param>
            <param name="eventSourceType">The type of the observable.</param>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <param name="isMarshalEventToCurrentThreadEnabled"><c>true</c> if the current <see cref="T:System.Threading.SynchronizationContext"/> should be captured to execute the event handler.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterObserver``1(System.String,System.Type,System.EventHandler{``0},System.Threading.SynchronizationContext)">
            <summary>
            Registers an event delegate to handle a specific event published by a specific observable type.
            </summary>
            <typeparam name="TEventArgs">The type of the event args object.</typeparam>
            <param name="eventName">The name of the observed event.</param>
            <param name="eventSourceType">The type of the observable.</param>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <param name="synchronizationContext">The <see cref="T:System.Threading.SynchronizationContext"/> that the event delegate is to be executed on.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterGlobalObserver(System.String,System.Delegate)">
            <summary>
            Register an event delegate to handle a specific event which could be published by any type.
            </summary>
            <param name="eventName">The name of the observed event.</param>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterGlobalObserver(System.String,System.Delegate,System.Boolean)">
            <summary>
            Register an event delegate to handle a specific event which could be published by any type.
            </summary>
            <param name="eventName">The name of the observed event.</param>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <param name="isMarshalEventToCurrentThreadEnabled"><c>true</c> if the current <see cref="T:System.Threading.SynchronizationContext"/> should be captured to execute the event handler.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterGlobalObserver(System.String,System.Delegate,System.Threading.SynchronizationContext)">
            <summary>
            Register an event delegate to handle a specific event which could be published by any type.
            </summary>
            <param name="eventName">The name of the observed event.</param>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <param name="synchronizationContext">The <see cref="T:System.Threading.SynchronizationContext"/> that the event delegate is to be executed on.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterGlobalObserver``1(System.String,System.EventHandler{``0})">
            <summary>
            Register an event delegate to handle a specific event which could be published by any type.
            </summary>
            <typeparam name="TEventArgs">The type of the event args object.</typeparam>
            <param name="eventName">The name of the observed event.</param>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterGlobalObserver``1(System.String,System.EventHandler{``0},System.Boolean)">
            <summary>
            Register an event delegate to handle a specific event which could be published by any type.
            </summary>
            <typeparam name="TEventArgs">The type of the event args object.</typeparam>
            <param name="eventName">The name of the observed event.</param>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <param name="isMarshalEventToCurrentThreadEnabled"><c>true</c> if the current <see cref="T:System.Threading.SynchronizationContext"/> should be captured to execute the event handler.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterGlobalObserver``1(System.String,System.EventHandler{``0},System.Threading.SynchronizationContext)">
            <summary>
            Register an event delegate to handle a specific event which could be published by any type.
            </summary>
            <typeparam name="TEventArgs">The type of the event args object.</typeparam>
            <param name="eventName">The name of the observed event.</param>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <param name="synchronizationContext">The <see cref="T:System.Threading.SynchronizationContext"/> that the event delegate is to be executed on.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterGlobalObserver(System.Delegate)">
            <summary>
            Registers a handler for any registered event source with a compatible event delegate signature.
            </summary>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterGlobalObserver(System.Delegate,System.Boolean)">
            <summary>
            Registers a handler for any registered event source with a compatible event delegate signature.
            </summary>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <param name="isMarshalEventToCurrentThreadEnabled"><c>true</c> if the current <see cref="T:System.Threading.SynchronizationContext"/> should be captured to execute the event handler.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterGlobalObserver(System.Delegate,System.Threading.SynchronizationContext)">
            <summary>
            Registers a handler for any registered event source with a compatible event delegate signature.
            </summary>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <param name="synchronizationContext">The <see cref="T:System.Threading.SynchronizationContext"/> that the event delegate is to be executed on.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterGlobalObserver``1(System.EventHandler{``0})">
            <summary>
            Registers a handler for any registered event source with a compatible event delegate signature.
            </summary>
            <typeparam name="TEventArgs">The type of the event args object.</typeparam>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterGlobalObserver``1(System.EventHandler{``0},System.Boolean)">
            <summary>
            Registers a handler for any registered event source with a compatible event delegate signature.
            </summary>
            <typeparam name="TEventArgs">The type of the event args object.</typeparam>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <param name="isMarshalEventToCurrentThreadEnabled"><c>true</c> if the current <see cref="T:System.Threading.SynchronizationContext"/> should be captured to execute the event handler.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRegisterGlobalObserver``1(System.EventHandler{``0},System.Threading.SynchronizationContext)">
            <summary>
            Registers a handler for any registered event source with a compatible event delegate signature.
            </summary>
            <typeparam name="TEventArgs">The type of the event args object.</typeparam>
            <param name="eventHandler">A delegate that handles the specified event.</param>
            <param name="synchronizationContext">The <see cref="T:System.Threading.SynchronizationContext"/> that the event delegate is to be executed on.</param>
            <returns><c>true</c> when registration was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRemoveObservable(System.Object,System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Unregister the event publisher for a collection of specified events.
            </summary>
            <param name="eventSource">The event publisher instance.</param>
            <param name="eventNames">The names of the events to unregister.</param>
            <param name="removeEventObservers">If <c>true</c> removes all event listenerHandlerMap of the specified events. The value is <c>false</c> by default.</param>
            <returns><c>true</c> when removal was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRemoveObservable(System.Object,System.Boolean)">
            <summary>
            Unregister the event publisher for all events.
            </summary>
            <param name="eventSource">The event publisher instance.</param>
            <param name="removeEventObservers">If <c>true</c> removes all event listenerHandlerMap of the specified events. The value is <c>false</c> by default.</param>
            <returns><c>true</c> when removal was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRemoveObserver(System.String,System.Type,System.Delegate)">
            <summary>
            Removes the event handler for a specified event of a certain event publisher type.
            </summary>
            <param name="eventName">The event name of the event that the delegate is handling.</param>
            <param name="eventSourceType">The type of the event publisher.</param>
            <param name="eventHandler">The event handler to remove.</param>
            <returns><c>true</c> when removal was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRemoveObserver``1(System.String,System.Type,System.EventHandler{``0})">
            <summary>
            Removes the event handler for a specified event of a certain event publisher type.
            </summary>
            <typeparam name="TEventArgs">The type of the event args object.</typeparam>
            <param name="eventName">The event name of the event that the delegate is handling.</param>
            <param name="eventSourceType">The type of the event publisher.</param>
            <param name="eventHandler">The event handler to remove.</param>
            <returns><c>true</c> when removal was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRemoveAllObservers(System.String)">
            <summary>
            Removes all event handlers for a specified event no matter event publisher type.
            </summary>
            <param name="eventName">The event name of the event that the delegate is handling.</param>
            <returns><c>true</c> when removal was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRemoveAllObservers(System.String,System.Type)">
            <summary>
            Removes all event handlers for a specific event publisher type and specific event.
            </summary>
            <param name="eventName">The event name of the event that the delegate is handling.</param>
            <param name="eventSourceType">The type of the event publisher.</param>
            <returns><c>true</c> when removal was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRemoveAllObservers(System.Type)">
            <summary>
            Removes all event handlers for a specified event publisher type.
            </summary>
            <param name="eventSourceType">The type of the event publisher.</param>
            <returns><c>true</c> when removal was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRemoveGlobalObserver(System.String,System.Delegate)">
            <summary>
            Removes the event handler for a specified event no matter the event publisher type.
            </summary>
            <param name="eventName">The event name of the event that the delegate is handling.</param>
            <param name="eventHandler">The event handler to remove</param>
            <returns><c>true</c> when removal was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRemoveGlobalObserver``1(System.String,System.EventHandler{``0})">
            <summary>
            Removes the event handler for a specified event no matter the event publisher type.
            </summary>
            <typeparam name="TEventArgs">The type of the event args object.</typeparam>
            <param name="eventName">The event name of the event that the delegate is handling.</param>
            <param name="eventHandler">The event handler to remove</param>
            <returns><c>true</c> when removal was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRemoveGlobalObserver(System.Delegate)">
            <summary>
            Removes the event handler for all registered events with a compatible event delegate signature.
            </summary>
            <param name="eventHandler">The event handler to remove.</param>
            <returns><c>true</c> when removal was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IEventAggregator.TryRemoveGlobalObserver``1(System.EventHandler{``0})">
            <summary>
            Removes the event handler for all registered events with a compatible event delegate signature.
            </summary>
            <typeparam name="TEventArgs">The type of the event args object.</typeparam>
            <param name="eventHandler">The event handler to remove.</param>
            <returns><c>true</c> when removal was successful, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:BionicCode.Utilities.Net.IInitializable">
            <summary>
            An interface to enable polymorphism for types like view model classes etc. that require an explicit (asynchronous) initialization.
            </summary>
            <remarks>It's considered bad practice to have a longrunning cobstructor. Also constructors don't have an async context. 
            <br/>Deferring the initilaization of the instance is a convenient way to avoid the shortcommings and code smells.
            <br/>It's also a clean way to "lazy" initialize expensive resources.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.IInitializable.InitializeAsync">
            <summary>
            Asynchronous method that executes the insatnce initialization routine.
            </summary>
            <returns>Return <c>true</c> when initialized successfully, otherwise <c>false</c>.</returns>
        </member>
        <member name="P:BionicCode.Utilities.Net.IInitializable.IsInitialized">
            <summary>
            Returns whether the instance is already initialized.
            </summary>
            <value><c>true</c> when <see cref="M:BionicCode.Utilities.Net.IInitializable.InitializeAsync"/> was already called, otherwise <c>false</c>.</value>
        </member>
        <member name="T:BionicCode.Utilities.Net.INullObject">
            <summary>
            Null-Object Pattern implementation
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.INullObject.IsNull">
            <summary>
            Property to indicate whether the current NULL type is a shared instance or a new instance should be created for each request.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.AutoResetStream">
            <summary>
            Decorates a <see cref="T:System.IO.Stream"/> instance to support auto-rewind after read/write access.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.AutoResetStream.BaseStream">
            <summary>
            The decorated <see cref="T:System.IO.Stream"/> instance which will be extended.
            </summary>
            <value>An instance of type <see cref="T:System.IO.Stream"/>. This instance will be decorated to extend the default <see cref="T:System.IO.Stream"/> features and behaviors.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.AutoResetStream.ResetOrigin">
            <summary>
            Defines the position to which the stream should reset to.
            </summary>
            <value>A <see cref="T:System.IO.SeekOrigin"/> value.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.AutoResetStream.IsDisposingDecoratedStream">
            <summary>
            Gets whether the decorated underlying <see cref="T:System.IO.Stream"/> will be closed or disposed when the <see cref="T:BionicCode.Utilities.Net.AutoResetStream"/> instance is closed or disposed. Use constructor to set the value in order to configure the behavior.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.#ctor">
            <summary>
            Default constructor. Creates an instance where the <see cref="P:BionicCode.Utilities.Net.AutoResetStream.BaseStream"/> is set to a <see cref="T:System.IO.MemoryStream"/>.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.#ctor(System.IO.Stream)">
            <summary>
            Constructor which accepts the <see cref="T:System.IO.Stream"/> instance to decorate in order to extend its behavior.
            </summary>
            <param name="baseStream">The <see cref="T:System.IO.Stream"/> instance to decorate in order to extend its behavior.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Constructor which accepts the <see cref="T:System.IO.Stream"/> instance to decorate in order to extend its behavior.
            </summary>
            <param name="baseStream">The <see cref="T:System.IO.Stream"/> instance to decorate in order to extend its behavior.</param>
            <param name="leaveDecoratedStreamOpen">When set to <c>true</c> the decorated underlying <see cref="T:System.IO.Stream"/> will be disposed or closed too, if the <see cref="T:BionicCode.Utilities.Net.AutoResetStream"/> is disposed or closed.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.#ctor(System.IO.Stream,System.IO.SeekOrigin,System.Boolean)">
            <summary>
            Constructor which accepts the <see cref="T:System.IO.Stream"/> instance to decorate in order to extend its behavior.
            </summary>
            <param name="baseStream">The <see cref="T:System.IO.Stream"/> instance to decorate in order to extend its behavior.</param>
            <param name="resetOrigin">The origin to which the stream should be reset to.</param>
            <param name="leaveDecoratedStreamOpen">When set to <c>true</c> the decorated underlying <see cref="T:System.IO.Stream"/> will be disposed or closed too, if the <see cref="T:BionicCode.Utilities.Net.AutoResetStream"/> is disposed or closed.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.Reset(System.IO.SeekOrigin)">
            <summary>
            Resets the <see cref="P:System.IO.Stream.Position"/> to an offset of '0' relative to the provided <paramref name="seekOrigin"/>.
            </summary>
            <param name="seekOrigin">The optional relative position of the <see cref="T:System.IO.Stream"/> to apply the zero offset to. The default is <see cref="F:System.IO.SeekOrigin.Begin"/>.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.Flush">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.ReadByte">
            <inheritdoc />
        </member>
        <member name="P:BionicCode.Utilities.Net.AutoResetStream.ReadTimeout">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.SetLength(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.WriteByte(System.Byte)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="P:BionicCode.Utilities.Net.AutoResetStream.WriteTimeout">
            <inheritdoc />
        </member>
        <member name="P:BionicCode.Utilities.Net.AutoResetStream.CanRead">
            <inheritdoc />
        </member>
        <member name="P:BionicCode.Utilities.Net.AutoResetStream.CanTimeout">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.Close">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.AutoResetStream.ToString">
            <inheritdoc />
        </member>
        <member name="P:BionicCode.Utilities.Net.AutoResetStream.CanSeek">
            <inheritdoc />
        </member>
        <member name="P:BionicCode.Utilities.Net.AutoResetStream.CanWrite">
            <inheritdoc />
        </member>
        <member name="P:BionicCode.Utilities.Net.AutoResetStream.Length">
            <inheritdoc />
        </member>
        <member name="P:BionicCode.Utilities.Net.AutoResetStream.Position">
            <inheritdoc />
        </member>
        <member name="T:BionicCode.Utilities.Net.FileExtensions">
            <summary>
            An enumeration of common file extensions.
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.NotDefined">
            <summary>
            Undefined value.
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Any">
            <summary>
            Represents wildcard '.*'
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Log">
            <summary>
            .log
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Txt">
            <summary>
            .txt
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Ini">
            <summary>
            .ini
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Csv">
            <summary>
            .csv
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Bat">
            <summary>
            .bat
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Bak">
            <summary>
            .bak
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Config">
            <summary>
            .config
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Sys">
            <summary>
            .sys
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Reg">
            <summary>
            .reg
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Info">
            <summary>
            .info
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Inf">
            <summary>
            .inf
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Help">
            <summary>
            .help
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Hlp">
            <summary>
            .hlp
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Dll">
            <summary>
            .dll
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Bin">
            <summary>
            .bin
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Old">
            <summary>
            .old
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Iii">
            <summary>
            .iii
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Xml">
            <summary>
            .xml
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Jpg">
            <summary>
            .jpg
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Jpeg">
            <summary>
            .jpeg
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Bmp">
            <summary>
            .bmp
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Exe">
            <summary>
            .exe
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Com">
            <summary>
            .com
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Cgc">
            <summary>
            .cgc
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Cgt">
            <summary>
            .cgt
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Cfg">
            <summary>
            .cfg
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Png">
            <summary>
            .png
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Zip">
            <summary>
            .zip
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Bz2">
            <summary>
            .bz2
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Gz">
            <summary>
            .gz
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.SevenZip">
            <summary>
            .sevenzip
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Xz">
            <summary>
            .xz
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Lz">
            <summary>
            .lz
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Rar">
            <summary>
            .rar
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Tar">
            <summary>
            .tar
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Xaml">
            <summary>
            .xaml
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Cpp">
            <summary>
            .cpp
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.C">
            <summary>
            .c
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Cs">
            <summary>
            .cs
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Js">
            <summary>
            .js
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.Archive">
            <summary>
            .archive
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.FileExtensions.NonArchive">
            <summary>
            .nonarchive
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.IValueInverter">
            <summary>
            Provide an implementation to invert an object or objects.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.IValueInverter.TryInvertValue(System.Object,System.Object@)">
            <summary>
            Trys to invert a value. Won't throw an exception if operation fails.
            </summary>
            <param name="value"></param>
            <param name="invertedValue"></param>
            <returns><c>true</c> when successful, otherwise <c>false</c></returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IValueInverter.InvertValue(System.Object)">
            <summary>
            Throws an exception if operation has failed.
            </summary>
            <param name="value"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
            <returns>The inverted value.</returns>
        </member>
        <member name="T:BionicCode.Utilities.Net.Math">
            <summary>
            Additional mth functions
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.Math.NormDist(System.Double,System.Double,System.Double)">
            <summary>
            Calculates the normal distribution. The interval used is [µ-5*σ...µ+5*σ], where µ=mean and σ=standard deviation.
            </summary>
            <param name="mean">The arithmetic mean of the data series.</param>
            <param name="standardDeviation">The sigma i.e. standard deviation of the data series.</param>
            <param name="resolution">The factor to calculate the increments of the 'x' values used to calculate the normal distribution. 
            <br/>The smallest absolute value of the range is multiplied with the <paramref name="resolution"/> value.</param>
            <returns>The data set of x,y points. Can be used to plot the graph.
            <br/>The data set always contains the mean µ (0σ), ±1σ, ±2σ, ±3σ.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.Math.NormDist(System.Double,System.Double,System.Double,System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Calculates the normal distribution. The interval used is [µ-5*σ...µ+5*σ], where µ=mean and σ=standard deviation.
            </summary>
            <param name="mean">The arithmetic mean of the data series.</param>
            <param name="standardDeviation">The sigma i.e. standard deviation of the data series.</param>
            <param name="resolution">The factor to calculate the increments of the 'x' values used to calculate the normal distribution. 
            <br/>The smallest absolute value of the range is multiplied with the <paramref name="resolution"/> value.</param>
            <param name="existingXValues">Existing x values that the function should explicitly calculate the result from. Those values are merged nto the normal distributation.</param>
            <returns>The data set of x,y points. Can be used to plot the graph. 
            <br/>The data set always contains the mean µ (0σ), ±1σ, ±2σ, ±3σ.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:BionicCode.Utilities.Net.Math.NormDistOf(System.Double,System.Double,System.Double)" -->
        <member name="M:BionicCode.Utilities.Net.Math.EnumerateNormDist(System.Double,System.Double,System.Double)">
            <summary>
            Calculates the normal distribution and retuns an enumerable collection. The interval used is [µ-5*σ...µ+5*σ], where µ=mean and σ=standard deviation.
            </summary>
            <param name="mean">The arithmetic mean of the data series.</param>
            <param name="standardDeviation">The sigma i.e. standard deviation of the data series.</param>
            <param name="resolution">The factor to calculate the increments of the 'x' values used to calculate the normal distribution. 
            <br/>The smallest absolute value of the range is multiplied with the <paramref name="resolution"/> value.</param>
            <returns>The data set of x,y points. Can be used to plot the graph.
            <br/>The data set always contains the mean µ (0σ), ±1σ, ±2σ, ±3σ.</returns>
            <remarks><see cref="M:BionicCode.Utilities.Net.Math.EnumerateNormDist(System.Double,System.Double,System.Double)"/> and <see cref="M:BionicCode.Utilities.Net.Math.NormDist(System.Double,System.Double,System.Double)"/> differ as follows: When you use <see cref="M:BionicCode.Utilities.Net.Math.EnumerateNormDist(System.Double,System.Double,System.Double)"/>, you can start enumerating the collection of cartesian points before the whole collection is returned. 
            <br/>When you use <see cref="M:BionicCode.Utilities.Net.Math.NormDist(System.Double,System.Double,System.Double)"/>, you must wait for the whole array of cartesian points to be returned before you can access the array. 
            <br/>Therefore, when you are expecting a huge spread of values i.e. a big standard deviation value for <paramref name="standardDeviation"/>, <see cref="M:BionicCode.Utilities.Net.Math.EnumerateNormDist(System.Double,System.Double,System.Double)"/> can be more efficient.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_LessThan(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_GreaterThan(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_LessThan(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_GreaterThan(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_LessThan(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_GreaterThan(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_LessThan(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_GreaterThan(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_LessThan(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_GreaterThan(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Multiply(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Division(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Multiply(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Division(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Multiply(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Division(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Multiply(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Division(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Multiply(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Division(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Multiply(BionicCode.Utilities.Net.Microseconds,System.Double)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Division(BionicCode.Utilities.Net.Microseconds,System.Double)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Equality(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Inequality(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Equality(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Inequality(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Equality(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Inequality(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Equality(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Inequality(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Equality(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Microseconds.op_Inequality(BionicCode.Utilities.Net.Microseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_LessThan(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_GreaterThan(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_LessThan(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_GreaterThan(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_LessThan(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_GreaterThan(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_LessThan(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_GreaterThan(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_LessThan(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_GreaterThan(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Multiply(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Division(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Multiply(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Division(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Multiply(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Division(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Multiply(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Division(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Multiply(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Division(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Multiply(BionicCode.Utilities.Net.Milliseconds,System.Double)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Division(BionicCode.Utilities.Net.Milliseconds,System.Double)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Equality(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Inequality(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Equality(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Inequality(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Equality(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Inequality(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Equality(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Inequality(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Equality(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Milliseconds.op_Inequality(BionicCode.Utilities.Net.Milliseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_LessThan(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_LessThanOrEqual(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_GreaterThan(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_LessThan(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_LessThanOrEqual(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_GreaterThan(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_LessThan(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_LessThanOrEqual(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_GreaterThan(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_LessThan(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_LessThanOrEqual(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_GreaterThan(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_LessThan(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_LessThanOrEqual(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_GreaterThan(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Multiply(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Division(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Multiply(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Division(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Multiply(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Division(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Multiply(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Division(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Multiply(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Division(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Multiply(BionicCode.Utilities.Net.Minutes,System.Double)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Division(BionicCode.Utilities.Net.Minutes,System.Double)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Equality(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Inequality(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Equality(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Inequality(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Equality(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Inequality(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Equality(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Inequality(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Equality(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Minutes.op_Inequality(BionicCode.Utilities.Net.Minutes,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_LessThan(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_GreaterThan(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_LessThan(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_GreaterThan(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_LessThan(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_GreaterThan(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_LessThan(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_GreaterThan(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_LessThan(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_GreaterThan(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Multiply(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Division(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Multiply(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Division(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Multiply(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Division(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Multiply(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Division(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Multiply(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Division(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Multiply(BionicCode.Utilities.Net.Nanoseconds,System.Double)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Division(BionicCode.Utilities.Net.Nanoseconds,System.Double)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Equality(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Inequality(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Equality(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Inequality(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Equality(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Inequality(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Equality(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Inequality(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Equality(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Nanoseconds.op_Inequality(BionicCode.Utilities.Net.Nanoseconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="T:BionicCode.Utilities.Net.AsyncProfilerOptions">
            <summary>
            Configures the <see cref="T:BionicCode.Utilities.Net.Profiler"/> to use with async API.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncProfilerOptions.#ctor">
            <summary>
            Default constructor.
            </summary>
            <remarks>
            Initializes the instance with 100 iterations, and the default number of warmup iteration (defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultWarmupCount"/>) and with the default time unit (defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultBaseUnit"/>).
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncProfilerOptions.#ctor(System.Int32,System.Int32,BionicCode.Utilities.Net.ProfilerLoggerDelegate,BionicCode.Utilities.Net.TimeUnit)">
            <summary>
            Constructor.
            </summary>
            <param name="iterations">The number of iterations to execute the profiled code.</param>
            <param name="warmupIterations">The number of warmup iterations.</param>
            <param name="logger">A synchronous logging delegate.</param>
            <param name="baseUnit">The desired base unit.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncProfilerOptions.#ctor(System.Int32,System.Int32,BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate,BionicCode.Utilities.Net.TimeUnit)">
            <summary>
            Constructor.
            </summary>
            <param name="iterations">The number of iterations to execute the profiled code.</param>
            <param name="warmupIterations">The number of warmup iterations.</param>
            <param name="asyncLogger">An asynchronous logging delegate.</param>
            <param name="baseUnit">The desired base unit.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.AsyncProfilerOptions.#ctor(System.Int32,System.Int32,BionicCode.Utilities.Net.ProfilerLoggerDelegate,BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate,BionicCode.Utilities.Net.TimeUnit)">
            <summary>
            Constructor.
            </summary>
            <param name="iterations">The number of iterations to execute the profiled code.</param>
            <param name="warmupIterations">The number of warmup iterations.</param>
            <param name="logger">A synchronous logging delegate.</param>
            <param name="asyncLogger">An asynchronous logging delegate.</param>
            <param name="baseUnit">The desired base unit.</param>
        </member>
        <member name="P:BionicCode.Utilities.Net.AsyncProfilerOptions.AsyncLogger">
            <summary>
            An asynchronous delegate to handle the result.
            </summary>
            <remarks>
            The async profiler API will use either of the defined loggers. When both <see cref="P:BionicCode.Utilities.Net.AsyncProfilerOptions.AsyncLogger"/> and <see cref="P:BionicCode.Utilities.Net.ProfilerOptions.Logger"/> are defined, both will be executed.
            </remarks>
        </member>
        <member name="T:BionicCode.Utilities.Net.Profiler">
            <summary>
            Helper methods to measure code execution time.
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.Profiler.DefaultWarmupCount">
            <summary>
            The default value used by the <see cref="T:BionicCode.Utilities.Net.Profiler"/> to execute warmup iterations (to initilaize the JIT compiler).
            </summary>
            <remarks>Use the appropriate overloads of the profiler methods or define a <see cref="T:BionicCode.Utilities.Net.ProfilerOptions"/> object to change the default behavior.</remarks>
        </member>
        <member name="F:BionicCode.Utilities.Net.Profiler.DefaultBaseUnit">
            <summary>
            The default base unit that all results are transformed to.
            </summary>
            <remarks>
            Internally time is recorded in microseconds and then converted to the desired base unit (e.g., ms). The usual timer resolution on most modern machines is 100 ns (see <see cref="P:System.TimeSpan.Ticks"/> to learn more. Call the static <see cref="F:System.Diagnostics.Stopwatch.IsHighResolution"/> field to know if the executing machine supports that high resolution.)
            <para>
            Use the appropriate overloads of the profiler methods or define a <see cref="T:BionicCode.Utilities.Net.ProfilerOptions"/> object to change the default behavior.
            </para>
            </remarks>
        </member>
        <member name="F:BionicCode.Utilities.Net.Profiler.DefaultIterationCount">
            <summary>
            The default number of iterations to execute the profiled code.
            </summary>
            <remarks>
            Use the appropriate overloads of the profiler methods or define a <see cref="T:BionicCode.Utilities.Net.ProfilerOptions"/> object to change the default behavior.
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTime(System.Action,BionicCode.Utilities.Net.ProfilerOptions,System.String,System.Int32)">
            <summary>
            Measures the execution time of a method using a default warmup iteration count of '4' to warmup the JIT compiler.
            </summary>
            <param name="action">The code to measure execution time.</param>
            <param name="options">The options object to customize the behavior of the <see cref="T:BionicCode.Utilities.Net.Profiler"/>.</param>
            <returns>The result containing the average execution time of all iterations as <see cref="T:System.TimeSpan"/>.</returns>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the value of <see cref="P:BionicCode.Utilities.Net.ProfilerOptions.Iterations"/> or <see cref="P:BionicCode.Utilities.Net.ProfilerOptions.WarmupIterations"/> is not between '0' and 'ulong.MaxValue'.</exception>
            <remarks>
            The results are calculated using the default time base defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultBaseUnit"/>.
            <para>
            Use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTime(System.Action,System.Int32,BionicCode.Utilities.Net.ProfilerLoggerDelegate,BionicCode.Utilities.Net.TimeUnit,System.String,System.Int32)"/> and provide an instance of the <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerDelegate"/>  to enable logging.
            <br/>Or use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Action,System.Int32,BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate,System.String,System.Int32)"/> overload and provide a <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate"/> delegate to enable asynchronous logging (for example, use asnchronous API to write the results to a file).
            </para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTime(System.Action,System.Int32,System.String,System.Int32)">
            <summary>
            Measures the execution time of a method using a default warmup iteration count of '4' to warmup the JIT compiler.
            </summary>
            <param name="action">The code to measure execution time.</param>
            <returns>The average execution time of all <paramref name="runCount"/> number of iterations as <see cref="T:System.TimeSpan"/>.</returns>
            <param name="runCount">Number of iterations the <paramref name="action"/> should be executed.</param>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the value of<paramref name="runCount"/> is not between '0' and 'ulong.MaxValue'.</exception>
            <remarks>
            <para>
            Use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTime(System.Action,System.Int32,BionicCode.Utilities.Net.ProfilerLoggerDelegate,BionicCode.Utilities.Net.TimeUnit,System.String,System.Int32)"/> and provide an instance of the <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerDelegate"/>  to enable logging.
            <br/>Or use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Action,System.Int32,BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate,System.String,System.Int32)"/> overload and provide a <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate"/> delegate to enable asynchronous logging (for example, use asnchronous API to write the results to a file).
            </para>
            <para>
            The results are calculated using the default time base defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultBaseUnit"/>.
            Use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTime(System.Action,BionicCode.Utilities.Net.ProfilerOptions,System.String,System.Int32)"/> overload to customize the behavior, e.g. time base or the number of warmup iterations.
            </para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTime(System.Action,System.Int32,BionicCode.Utilities.Net.ProfilerLoggerDelegate,BionicCode.Utilities.Net.TimeUnit,System.String,System.Int32)">
            <summary>
            Measures the execution time of a method using a default warmup iteration count of '4' to warmup the JIT compiler.
            </summary>
            <param name="action">The code to measure execution time.</param>
            <returns>The average execution time of all <paramref name="runCount"/> number of iterations as <see cref="T:System.TimeSpan"/>.</returns>
            <param name="runCount">Number of iterations the <paramref name="action"/> should be executed.</param>
            <param name="baseUnit">The optional time unit that theresults should be converted to. The default is <see cref="F:BionicCode.Utilities.Net.TimeUnit.Milliseconds"/>. </param>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="logger">A delegate of type <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerDelegate"/> which can be used to automatically print the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary" /> to a destination (e.g. file) in the following formatting:
            
            <br/>
            <code>
                      ╭───────────────┬────────────────────────────┬────────────────╮
                      | Iteration #   │ Duration [ms]              │ Is cancelled   |
                      ┝━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━┥
                      │ 1             │                     1.0512 │ False          |
                      │ 2             │                     1.0020 │ False          │
                      │ 3             │                     0.8732 │ False          │
                      │ 4             │                     0.0258 │ True (ignored) │
                      │ 5             │                     0.9943 │ False          │
            ╭═════════╧═══════════════╪════════════════════════════┼────────────────┤
            │ Total:    -             │                     3.9207 │                │
            │ Min:      3             │                     0.8732 │                │
            │ Max:      1             │                     1.0512 │                │
            │ Average:  -             │                     0.9802 │                │
            ╰─────────────────────────┴────────────────────────────┴────────────────╯
            </code></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the value of<paramref name="runCount"/> is not between '0' and 'ulong.MaxValue'.</exception>
            <remarks>
            <para>
            Provide an instance of the <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerDelegate"/> delegate for the <paramref name="logger"/> parameter to control the output target or customize the formatting.
            <br/> Use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Action,BionicCode.Utilities.Net.AsyncProfilerOptions,System.String,System.Int32)"/> or <see cref="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Action,System.Int32,BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate,System.String,System.Int32)"/> overload to enable asynchronous logging.
            </para>
            <para>
            The results are calculated using the default time base defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultBaseUnit"/>.
            Use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTime(System.Action,BionicCode.Utilities.Net.ProfilerOptions,System.String,System.Int32)"/> overload to customize the behavior, e.g. time base or the number of warmup iterations.
            </para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Action,BionicCode.Utilities.Net.AsyncProfilerOptions,System.String,System.Int32)">
            <summary>
            Measures the execution time of a method using a default warump iteration cvount of '4' to warmup the JIT compiler.
            </summary>
            <param name="action">The code to measure execution time.</param>
            <param name="options">The options object to customize the behavior of the <see cref="T:BionicCode.Utilities.Net.Profiler"/>.</param>
            <returns>The profiling result.</returns>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the value of <see cref="P:BionicCode.Utilities.Net.ProfilerOptions.Iterations"/> or <see cref="P:BionicCode.Utilities.Net.ProfilerOptions.WarmupIterations"/> is not between '0' and 'ulong.MaxValue'.</exception>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Action,System.Int32,BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate,System.String,System.Int32)">
            <summary>
            Measures the execution time of a method using a default warump iteration cvount of '4' to warmup the JIT compiler.
            </summary>
            <param name="action">The code to measure execution time.</param>
            <returns>The average execution time of all <paramref name="runCount"/> number of iterations as <see cref="T:System.TimeSpan"/>.</returns>
            <param name="runCount">Number of iterations the <paramref name="action"/> should be executed.</param>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="asyncLogger">A delegate of type <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate"/> which can be used to automatically print the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/> to a destination (e.g. file) in the following formatting:
            
            <br/>
            <code>
                      ╭───────────────┬────────────────────────────┬────────────────╮
                      | Iteration #   │ Duration [ms]              │ Is cancelled   |
                      ┝━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━┥
                      │ 1             │                     1.0512 │ False          |
                      │ 2             │                     1.0020 │ False          │
                      │ 3             │                     0.8732 │ False          │
                      │ 4             │                     0.0258 │ True (ignored) │
                      │ 5             │                     0.9943 │ False          │
            ╭═════════╧═══════════════╪════════════════════════════┼────────────────┤
            │ Total:    -             │                     3.9207 │                │
            │ Min:      3             │                     0.8732 │                │
            │ Max:      1             │                     1.0512 │                │
            │ Average:  -             │                     0.9802 │                │
            ╰─────────────────────────┴────────────────────────────┴────────────────╯
            </code></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the value of<paramref name="runCount"/> is not between '0' and 'ulong.MaxValue'.</exception>
            <remarks>
            Provide an instance of the <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate"/> delegate for the <paramref name="asyncLogger"/> parameter to control the output target or customize the formatting.   
            <para>
            The results are calculated using the default time base defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultBaseUnit"/>.
            Use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Action,BionicCode.Utilities.Net.AsyncProfilerOptions,System.String,System.Int32)"/> overload to customize the behavior, e.g. time base or the number of warmup iterations.
            </para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.Task},BionicCode.Utilities.Net.AsyncProfilerOptions,System.String,System.Int32)">
            <summary>
            Measures the execution time of a method using a default warmup iteration count of '4' to warmup the JIT compiler.
            </summary>
            <param name="options">The options object to customize the behavior of the profiler.</param>
            <param name="asyncAction">A delegate that executes the asynchronous code to measure execution time.</param>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the value of <see cref="P:BionicCode.Utilities.Net.ProfilerOptions.Iterations"/> or <see cref="P:BionicCode.Utilities.Net.ProfilerOptions.WarmupIterations"/> is not between '0' and 'ulong.MaxValue'.</exception>
            <returns>The profiling result.</returns> 
            <remarks>
            <para>Cancelled tasks are ignored when calculating the result (although the cancelled runs are listed in the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/>, but marked as cancelled).
            <br/>A cancelled task is a <see cref="T:System.Threading.Tasks.Task"/> where the <see cref="P:System.Threading.Tasks.Task.Status"/> returns either <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> or <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/> or an <see cref="T:System.OperationCanceledException"/> exception was thrown.</para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.Task},System.Int32,System.String,System.Int32)">
            <summary>
            Measures the execution time of a method using a default warmup iteration count of '4' to warmup the JIT compiler.
            </summary>
            <param name="asyncAction">A delegate that executes the asynchronous code to measure execution time.</param>
            <param name="runCount">Number of iterations the <paramref name="asyncAction"/> should be executed.</param>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the value of <paramref name="runCount"/> is not between '0' and 'ulong.MaxValue'.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> holding the average execution time of all <paramref name="runCount"/> number of iterations as <see cref="T:System.TimeSpan"/>.</returns> 
            <remarks>
            <para>Cancelled tasks are ignored when calculating the result (although the cancelled runs are listed in the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/>, but marked as cancelled).
            <br/>A cancelled task is a <see cref="T:System.Threading.Tasks.Task"/> where the <see cref="P:System.Threading.Tasks.Task.Status"/> returns either <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> or <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/> or an <see cref="T:System.OperationCanceledException"/> exception was thrown.</para>
            Use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.Task},System.Int32,BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate,System.String,System.Int32)"/> or <see cref="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.Task},BionicCode.Utilities.Net.AsyncProfilerOptions,System.String,System.Int32)"/> overload and provide an instance of the <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate"/> to enable asynchronous logging.
            <para>
            The results are calculated using the default time base defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultBaseUnit"/>.
            Use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.Task},BionicCode.Utilities.Net.AsyncProfilerOptions,System.String,System.Int32)"/> overload to customize the behavior, e.g. time base or the number of warmup iterations.
            </para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.ValueTask},BionicCode.Utilities.Net.AsyncProfilerOptions,System.String,System.Int32)">
            <summary>
            Measures the execution time of a method using a default warmup iteration count of '4' to warmup the JIT compiler.
            </summary>
            <param name="asyncAction">A delegate that executes the asynchronous code to measure execution time.</param>
            <param name="options">The options object to customize the behavior of the profiler.</param>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the value of <see cref="P:BionicCode.Utilities.Net.ProfilerOptions.Iterations"/> or <see cref="P:BionicCode.Utilities.Net.ProfilerOptions.WarmupIterations"/> is not between '0' and 'ulong.MaxValue'.</exception>
            <returns>The profiling result.</returns> 
            <remarks>
            <para>Cancelled tasks are ignored when calculating the result (although the cancelled runs are listed in the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/>, but marked as cancelled).
            <br/>A cancelled task is a <see cref="T:System.Threading.Tasks.Task"/> where the <see cref="P:System.Threading.Tasks.Task.Status"/> returns either <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> or <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/> or an <see cref="T:System.OperationCanceledException"/> exception was thrown.</para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.ValueTask},System.Int32,System.String,System.Int32)">
            <summary>
            Measures the execution time of a method using a default warmup iteration count of '4' to warmup the JIT compiler.
            </summary>
            <param name="asyncAction">A delegate that executes the asynchronous code to measure execution time.</param>
            <param name="runCount">Number of iterations the <paramref name="asyncAction"/> should be executed.</param>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the value of <paramref name="runCount"/> is not between '0' and 'ulong.MaxValue'.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> holding the average execution time of all <paramref name="runCount"/> number of iterations as <see cref="T:System.TimeSpan"/>.</returns> 
            <remarks>
            <para>
            Cancelled tasks are ignored when calculating the result (although the cancelled runs are listed in the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/>, but marked as cancelled).
            <br/>A cancelled task is a <see cref="T:System.Threading.Tasks.Task"/> where the <see cref="P:System.Threading.Tasks.Task.Status"/> returns either <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> or <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/> or an <see cref="T:System.OperationCanceledException"/> exception was thrown.
            </para>
            Use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.ValueTask},System.Int32,BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate,System.String,System.Int32)"/> or <see cref="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.ValueTask},BionicCode.Utilities.Net.AsyncProfilerOptions,System.String,System.Int32)"/> overload and provide an instance of the <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate"/> delegate to enable logging.
            <para>
            The results are calculated using the default time base defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultBaseUnit"/>.
            Use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.ValueTask},BionicCode.Utilities.Net.AsyncProfilerOptions,System.String,System.Int32)"/> overload to customize the behavior, e.g. time base or the number of warmup iterations.
            </para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.Task},System.Int32,BionicCode.Utilities.Net.ProfilerLoggerDelegate,System.String,System.Int32)">
            <summary>
            Measures the execution time of a method using a default warmup iteration count of '4' to warmup the JIT compiler.
            </summary>
            <param name="asyncAction">A delegate that executes the asynchronous code to measure execution time.</param>
            <param name="runCount">Number of iterations the <paramref name="asyncAction"/> should be executed.</param>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="logger">A delegate of type <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerDelegate"/> which can be used to automatically print the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/> to a destination (e.g. file) in the following formatting:
            
            <br/>
            <code>
                      ╭───────────────┬────────────────────────────┬────────────────╮
                      | Iteration #   │ Duration [ms]              │ Is cancelled   |
                      ┝━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━┥
                      │ 1             │                     1.0512 │ False          |
                      │ 2             │                     1.0020 │ False          │
                      │ 3             │                     0.8732 │ False          │
                      │ 4             │                     0.0258 │ True (ignored) │
                      │ 5             │                     0.9943 │ False          │
            ╭═════════╧═══════════════╪════════════════════════════┼────────────────┤
            │ Total:    -             │                     3.9207 │                │
            │ Min:      3             │                     0.8732 │                │
            │ Max:      1             │                     1.0512 │                │
            │ Average:  -             │                     0.9802 │                │
            ╰─────────────────────────┴────────────────────────────┴────────────────╯
            </code></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the value of <paramref name="runCount"/> is not between '0' and 'ulong.MaxValue'.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> holding the <see cref="T:BionicCode.Utilities.Net.ProfilerBatchResult"/> result which contains neta data like average execution time or a formatted report (<see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/>) of all <paramref name="runCount"/> number of iterations.</returns>
            <remarks>
            <para>
            Cancelled tasks are ignored when calculating the result (although the cancelled runs are listed in the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/>, but marked as cancelled).
            <br/>A cancelled task is a <see cref="T:System.Threading.Tasks.Task"/> where the <see cref="P:System.Threading.Tasks.Task.Status"/> returns either <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> or <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/> or an <see cref="T:System.OperationCanceledException"/> exception was thrown.
            </para>
            <para>
            The results are calculated using the default time base defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultBaseUnit"/>.
            Use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.Task},BionicCode.Utilities.Net.AsyncProfilerOptions,System.String,System.Int32)"/> overload to customize the behavior, e.g. time base or the number of warmup iterations.
            </para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.ValueTask},System.Int32,BionicCode.Utilities.Net.ProfilerLoggerDelegate,System.String,System.Int32)">
            <summary>
            Measures the execution time of a method using a default warmup iteration count of '4' to warmup the JIT compiler.
            </summary>
            <param name="asyncAction">A delegate that executes the asynchronous code to measure execution time.</param>
            <param name="runCount">Number of iterations the <paramref name="asyncAction"/> should be executed.</param>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="logger">A delegate of type <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerDelegate"/> which can be used to automatically print the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/> to a destination (e.g. file) in the following formatting:
            
            <br/>
            <code>
                      ╭───────────────┬────────────────────────────┬────────────────╮
                      | Iteration #   │ Duration [ms]              │ Is cancelled   |
                      ┝━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━┥
                      │ 1             │                     1.0512 │ False          |
                      │ 2             │                     1.0020 │ False          │
                      │ 3             │                     0.8732 │ False          │
                      │ 4             │                     0.0258 │ True (ignored) │
                      │ 5             │                     0.9943 │ False          │
            ╭═════════╧═══════════════╪════════════════════════════┼────────────────┤
            │ Total:    -             │                     3.9207 │                │
            │ Min:      3             │                     0.8732 │                │
            │ Max:      1             │                     1.0512 │                │
            │ Average:  -             │                     0.9802 │                │
            ╰─────────────────────────┴────────────────────────────┴────────────────╯
            </code></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the value of <paramref name="runCount"/> is not between '0' and 'ulong.MaxValue'.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> holding the <see cref="T:BionicCode.Utilities.Net.ProfilerBatchResult"/> result which contains neta data like average execution time or a formatted report (<see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/>) of all <paramref name="runCount"/> number of iterations.</returns>
            <remarks>
            <para>
            Cancelled tasks are ignored when calculating the result (although the cancelled runs are listed in the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/>, but marked as cancelled).
            <br/>A cancelled task is a <see cref="T:System.Threading.Tasks.Task"/> where the <see cref="P:System.Threading.Tasks.Task.Status"/> returns either <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> or <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/> or an <see cref="T:System.OperationCanceledException"/> exception was thrown.
            </para>
            <para>
            The results are calculated using the default time base defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultBaseUnit"/>.
            Use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.ValueTask},BionicCode.Utilities.Net.AsyncProfilerOptions,System.String,System.Int32)"/> overload to customize the behavior, e.g. time base or the number of warmup iterations.
            </para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.Task},System.Int32,BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate,System.String,System.Int32)">
            <summary>
            Measures the execution time of a method using a default warmup iteation count of '4' to wramup the JIT compiler.
            </summary>
            <param name="asyncAction">A delegate that executes the asynchronous code to measure execution time.</param>
            <param name="runCount">Number of iterations the <paramref name="asyncAction"/> should be executed.</param>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="asyncLogger">An asynchronous delegate of type <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate"/> which can be used to automatically let the <see cref="!:LogTimeAsync(Func&lt;Task&gt;, int, int, ProfilerLoggerAsyncDelegate, TimeUnit, string, int)"/> print the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/> to a destination (e.g. file) in the following formatting:
            
            <br/>
            <code>
                      ╭───────────────┬────────────────────────────┬────────────────╮
                      | Iteration #   │ Duration [ms]              │ Is cancelled   |
                      ┝━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━┥
                      │ 1             │                     1.0512 │ False          |
                      │ 2             │                     1.0020 │ False          │
                      │ 3             │                     0.8732 │ False          │
                      │ 4             │                     0.0258 │ True (ignored) │
                      │ 5             │                     0.9943 │ False          │
            ╭═════════╧═══════════════╪════════════════════════════┼────────────────┤
            │ Total:    -             │                     3.9207 │                │
            │ Min:      3             │                     0.8732 │                │
            │ Max:      1             │                     1.0512 │                │
            │ Average:  -             │                     0.9802 │                │
            ╰─────────────────────────┴────────────────────────────┴────────────────╯
            </code></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the value of<paramref name="runCount"/> is not between '0' and 'ulong.MaxValue'.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> holding the <see cref="T:BionicCode.Utilities.Net.ProfilerBatchResult"/> result which contains neta data like average execution time or a formatted report (<see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/>) of all <paramref name="runCount"/> number of iterations.</returns>
            <remarks>
            <para>
            Cancelled tasks are ignored when calculating the result (although the cancelled runs are listed in the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/>, but marked as cancelled).
            <br/>A cancelled task is a <see cref="T:System.Threading.Tasks.Task"/> where the <see cref="P:System.Threading.Tasks.Task.Status"/> returns either <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> or <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/> or an <see cref="T:System.OperationCanceledException"/> exception was thrown.
            </para>
            <para>
            The results are calculated using the default time base defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultBaseUnit"/>.
            Use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.Task},BionicCode.Utilities.Net.AsyncProfilerOptions,System.String,System.Int32)"/> overload to customize the behavior, e.g. time base or the number of warmup iterations.
            </para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.ValueTask},System.Int32,BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate,System.String,System.Int32)">
            <summary>
            Measures the execution time of a method.
            </summary>
            <param name="asyncAction">A delegate that executes the asynchronous code to measure execution time.</param>
            <param name="runCount">Number of iterations the <paramref name="asyncAction"/> should be executed.</param>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="asyncLogger">An asynchronous delegate of type <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate"/> which can be used to automatically let the <see cref="!:LogTimeAsync(Func&lt;Task&gt;, int, ProfilerLoggerAsyncDelegate, TimeUnit, string, int)"/> print the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/> to a destination (e.g. file) in the following formatting:
            
            <br/>
            <code>
                      ╭───────────────┬────────────────────────────┬────────────────╮
                      | Iteration #   │ Duration [ms]              │ Is cancelled   |
                      ┝━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━┥
                      │ 1             │                     1.0512 │ False          |
                      │ 2             │                     1.0020 │ False          │
                      │ 3             │                     0.8732 │ False          │
                      │ 4             │                     0.0258 │ True (ignored) │
                      │ 5             │                     0.9943 │ False          │
            ╭═════════╧═══════════════╪════════════════════════════┼────────────────┤
            │ Total:    -             │                     3.9207 │                │
            │ Min:      3             │                     0.8732 │                │
            │ Max:      1             │                     1.0512 │                │
            │ Average:  -             │                     0.9802 │                │
            ╰─────────────────────────┴────────────────────────────┴────────────────╯
            </code></param>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the value of<paramref name="runCount"/> is not between '0' and 'ulong.MaxValue'.</exception>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> holding the <see cref="T:BionicCode.Utilities.Net.ProfilerBatchResult"/> result which contains neta data like average execution time or a formatted report (<see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/>) of all <paramref name="runCount"/> number of iterations.</returns>
            <remarks>
            <para>
            Cancelled tasks are ignored when calculating the result (although the cancelled runs are listed in the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/>, but marked as cancelled).
            <br/>A cancelled task is a <see cref="T:System.Threading.Tasks.Task"/> where the <see cref="P:System.Threading.Tasks.Task.Status"/> returns either <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> or <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/> or an <see cref="T:System.OperationCanceledException"/> exception was thrown.
            </para>
            <para>
            The results are calculated using the default time base defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultBaseUnit"/>.
            Use the <see cref="M:BionicCode.Utilities.Net.Profiler.LogTimeAsync(System.Func{System.Threading.Tasks.ValueTask},BionicCode.Utilities.Net.AsyncProfilerOptions,System.String,System.Int32)"/> overload to customize the behavior, e.g. time base or the number of warmup iterations.
            </para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTimeScoped(BionicCode.Utilities.Net.ProfilerLoggerDelegate,BionicCode.Utilities.Net.ProfilerBatchResult@,BionicCode.Utilities.Net.TimeUnit,System.String,System.String,System.Int32)">
            <summary>
            Measures the execution time of a using block i.e. the scope of the <see cref="T:System.IDisposable"/>'s lifetime.
            </summary>
            <param name="logger">A delegate of type <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerDelegate"/> which can be used to automatically let this method print the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/> to a destination (e.g. file) in the following formatting:
            
            <br/>
            <code>
                      ╭───────────────┬────────────────────────────┬────────────────╮
                      | Iteration #   │ Duration [ms]              │ Is cancelled   |
                      ┝━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━┥
                      │ 1             │                     1.0512 │ False          |
                      │ 2             │                     1.0020 │ False          │
                      │ 3             │                     0.8732 │ False          │
                      │ 4             │                     0.0258 │ True (ignored) │
                      │ 5             │                     0.9943 │ False          │
            ╭═════════╧═══════════════╪════════════════════════════┼────────────────┤
            │ Total:    -             │                     3.9207 │                │
            │ Min:      3             │                     0.8732 │                │
            │ Max:      1             │                     1.0512 │                │
            │ Average:  -             │                     0.9802 │                │
            ╰─────────────────────────┴────────────────────────────┴────────────────╯
            </code></param>
            <param name="result">An <see langword="out"/> parameter holding the <see cref="T:BionicCode.Utilities.Net.ProfilerBatchResult"/> result which contains meta data like average execution time or a formatted report (<see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/>).</param>
            <param name="baseUnit">The optional time unit that theresults should be converted to. The default is <see cref="F:BionicCode.Utilities.Net.TimeUnit.Milliseconds"/>. </param>
            <param name="scopeName">The name of the scope. This value is automatically captured and set to the caller's member name. Therfore this optional parameter doesn't require an explicit value.</param>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <returns>An <see cref="T:System.IDisposable"/> to control the scope of the profiling.</returns>
            <remarks>
            Time is measured during the lifetime of the <see cref="T:System.IDisposable"/> instance: from time of creation to the final <see cref="M:System.IDisposable.Dispose"/> call.
            <br/>It's recommended to use the <see cref="T:System.IDisposable"/> managed by a using-statement or using-expression.
            <para>
            API docs: <see href="https://sampoh.de/github/docs/bioniccode.net/api/BionicCode.Utilities.Net.Profiler.html#BionicCode_Utilities_Net_Profiler_LogTimeScoped_BionicCode_Utilities_Net_ProfilerLoggerDelegate_BionicCode_Utilities_Net_ProfilerBatchResult__">IDisposable LogTimeScoped(ProfilerLoggerDelegate logger, out ProfilerBatchResult result)</see>
            </para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTimeScoped(BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate,BionicCode.Utilities.Net.ProfilerBatchResult@,BionicCode.Utilities.Net.TimeUnit,System.String,System.String,System.Int32)">
            <summary>
            Measures the execution time of a using block i.e. the scope of the <see cref="T:System.IDisposable"/>'s lifetime.
            </summary>
            <param name="asyncLogger">An asynchronous delegate of type <see cref="T:BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate"/> which can be used to automatically print the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/> to a destination (e.g. file) in the following formatting:
            
            <br/>
            <code>
                      ╭───────────────┬────────────────────────────┬────────────────╮
                      | Iteration #   │ Duration [ms]              │ Is cancelled   |
                      ┝━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━┥
                      │ 1             │                     1.0512 │ False          |
                      │ 2             │                     1.0020 │ False          │
                      │ 3             │                     0.8732 │ False          │
                      │ 4             │                     0.0258 │ True (ignored) │
                      │ 5             │                     0.9943 │ False          │
            ╭═════════╧═══════════════╪════════════════════════════┼────────────────┤
            │ Total:    -             │                     3.9207 │                │
            │ Min:      3             │                     0.8732 │                │
            │ Max:      1             │                     1.0512 │                │
            │ Average:  -             │                     0.9802 │                │
            ╰─────────────────────────┴────────────────────────────┴────────────────╯
            </code></param>
            <param name="result">An <see langword="out"/> parameter holding the <see cref="T:BionicCode.Utilities.Net.ProfilerBatchResult"/> result which contains meta data like average execution time or a formatted report (<see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/>).</param>
            <param name="baseUnit">The optional time unit that theresults should be converted to. The default is <see cref="F:BionicCode.Utilities.Net.TimeUnit.Milliseconds"/>. </param>
            <param name="scopeName">The name of the scope. This value is automatically captured and set to the caller's member name. Therfore this optional parameter doesn't require an explicit value.</param>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <returns>An <see cref="T:System.IDisposable"/> to control the scope of the profiling.</returns>
            <remarks>
            Time is measured during the lifetime of the <see cref="T:System.IDisposable"/> instance: from time of creation to the final <see cref="M:System.IDisposable.Dispose"/> call.
            <br/>It's recommended to use the <see cref="T:System.IDisposable"/> managed by a using-statement or using-expression.
            <para>
            API docs: <see href="https://sampoh.de/github/docs/bioniccode.net/api/BionicCode.Utilities.Net.Profiler.html#BionicCode_Utilities_Net_Profiler_LogTimeScoped_BionicCode_Utilities_Net_ProfilerLoggerAsyncDelegate_BionicCode_Utilities_Net_ProfilerBatchResult__">IDisposable LogTimeScoped(ProfilerLoggerAsyncDelegate, out ProfilerBatchResult)</see>
            </para>
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.LogTimeScoped(BionicCode.Utilities.Net.ProfilerBatchResult@,BionicCode.Utilities.Net.TimeUnit,System.String,System.String,System.Int32)">
            <summary>
            Measures the execution time of a using block i.e. the scope of the <see cref="T:System.IDisposable"/>'s lifetime.
            </summary>
            <param name="result">An <see langword="out"/> parameter holding the <see cref="T:BionicCode.Utilities.Net.ProfilerBatchResult"/> result which contains meta data like average execution time or a formatted report (<see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary"/>).</param>
            <param name="baseUnit">The optional time unit that theresults should be converted to. The default is <see cref="F:BionicCode.Utilities.Net.TimeUnit.Milliseconds"/>. </param>
            <param name="scopeName">The name of the scope. This value is automatically captured and set to the caller's member name. Therfore this optional parameter doesn't require an explicit value.</param>
            <param name="sourceFileName">The source file path of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <param name="lineNumber">The line in the source file of the profiled code. This value is automatically captured and therefore doesn't require an explicit value.</param>
            <returns>An <see cref="T:System.IDisposable"/> to control the scope of the profiling.</returns>
            <example></example>
            <remarks>
            Time is measured during the lifetime of the <see cref="T:System.IDisposable"/> instance: from time of creation to the final <see cref="M:System.IDisposable.Dispose"/> call.
            <br/>It's recommended to use the <see cref="T:System.IDisposable"/> managed by a using-statement or using-expression.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.CreateProfilerBuilder``1">
            <summary>
            Creates the builder object which configures and starts the attribute based profiling.
            </summary>
            <typeparam name="TTarget">The type to profile.</typeparam>
            <returns>
            The builder instance which configures and starts the attribute based profiling.</returns>
            <remarks>
            The member of the profiled type must be decorated with the <see cref="T:BionicCode.Utilities.Net.ProfileAttribute"/>. These members don't have to be <see langword="public"/>.
            <br/>Use the <see cref="T:BionicCode.Utilities.Net.ProfilerArgumentAttribute"/> to define the argument list which is used to invoke the member. The memeber can have multiple argument lists. Each argument list is invoked for the number of iterations that are set using the <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/>.
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.CreateProfilerBuilder(System.Type)">
            <summary>
            Creates the builder object which configures and starts the attribute based profiling.
            </summary>
            <param name="targetType">The type to profile.</param>
            <returns>
            The builder instance which configures and starts the attribute based profiling.</returns>
            <remarks>
            The member of the profiled type must be decorated with the <see cref="T:BionicCode.Utilities.Net.ProfileAttribute"/>. These members don't have to be <see langword="public"/>.
            <br/>Use the <see cref="T:BionicCode.Utilities.Net.ProfilerArgumentAttribute"/> to define the argument list which is used to invoke the member. The memeber can have multiple argument lists. Each argument list is invoked for the number of iterations that are set using the <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/>.
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.CreateProfilerBuilder(System.Type[])">
            <summary>
            Creates the builder object which configures and starts the attribute based profiling.
            </summary>
            <param name="targetTypes">A list of types to profile in a batch.</param>
            <returns>
            The builder instance which configures and starts the attribute based profiling.</returns>
            <remarks>
            The member of the profiled type must be decorated with the <see cref="T:BionicCode.Utilities.Net.ProfileAttribute"/>. These members don't have to be <see langword="public"/>.
            <br/>Use the <see cref="T:BionicCode.Utilities.Net.ProfilerArgumentAttribute"/> to define the argument list which is used to invoke the member. The memeber can have multiple argument lists. Each argument list is invoked for the number of iterations that are set using the <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/>.
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Profiler.CreateProfilerBuilder(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Creates the builder object which configures and starts the attribute based profiling.
            </summary>
            <param name="targetTypes">A list of types to profile in a batch.</param>
            <returns>
            The builder instance which configures and starts the attribute based profiling.</returns>
            <remarks>
            The member of the profiled type must be decorated with the <see cref="T:BionicCode.Utilities.Net.ProfileAttribute"/>. These members don't have to be <see langword="public"/>.
            <br/>Use the <see cref="T:BionicCode.Utilities.Net.ProfilerArgumentAttribute"/> to define the argument list which is used to invoke the member. The memeber can have multiple argument lists. Each argument list is invoked for the number of iterations that are set using the <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/>.
            </remarks>
        </member>
        <member name="T:BionicCode.Utilities.Net.ProfilerBatchResult">
            <summary>
            The result of a multi iteration benchmark session.
            <br/>The <see cref="T:BionicCode.Utilities.Net.ProfilerBatchResult"/> consolidates all <see cref="T:BionicCode.Utilities.Net.ProfilerResult"/> result items of a single benchmark run
            <br/>and provides meta data on hte collected data.
            </summary>
            <remarks>For example, the <see cref="T:BionicCode.Utilities.Net.ProfilerBatchResult"/> is returned by multi-run benchmark methods like <see cref="!:Profiler.LogTime(System.Action, int, string, string, int)"/>.</remarks>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.Index">
            <summary>
            The index of the current result batch.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.StandardDeviation">
            <summary>
            The stamdard deviation over all the <see cref="T:BionicCode.Utilities.Net.ProfilerResult"/> items in microseconds.
            </summary>
            <value>Stamdard deviation in microseconds.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.StandardDeviationConverted">
            <summary>
            The stamdard deviation over all the <see cref="T:BionicCode.Utilities.Net.ProfilerResult"/> items converted to the base unit.
            </summary>
            <value>Stamdard deviation converted from microseconds to the base unit defined by the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.BaseUnit"/> property.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.Variance">
            <summary>
            The variance over all the <see cref="T:BionicCode.Utilities.Net.ProfilerResult"/> items.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.HasCancelledProfiledTask">
            <summary>
            In case ansync operation was benchmarked, this property returns whether the <see cref="T:System.Threading.Tasks.Task"/> was cancelled or not.
            </summary>
            <value><see langword="true"/> if the benchmark series contains a cancelled run (where the <see cref="T:System.Threading.Tasks.Task"/> is cancelled).</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.IterationCount">
            <summary>
            The number of iterations the <see cref="T:BionicCode.Utilities.Net.Profiler"/> has run the specified operation.
            </summary>
            <value>The number of iterations (which is equivalent to the number of results) per argument list.</value>
            <remarks>Using the profiler with annotations (attributes) (see <see cref="T:BionicCode.Utilities.Net.ProfileAttribute"/>) allows to specify argument lists (see <see cref="T:BionicCode.Utilities.Net.ProfilerArgumentAttribute"/>) to simulate real-world behavior where usually the values of the arguments that are provided to the member change.
            <br/>A member is executed and profiled with each argument list for the number of the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.IterationCount"/> times.
            <br/>For example if a method is profiled with three argument lists and an iteration count of 10, the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.IterationCount"/> will return <c>10</c> and the total iterations run for the profiled member is <c>30</c>, the product of <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.IterationCount"/> and <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.ArgumentListCount"/> (see <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.TotalIterationCount"/>).</remarks>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.TotalIterationCount">
            <summary>
            The total number of iterations to conduct the profiling.
            </summary>
            <value>The value is based on the number of iterations and the number of argument lists. If <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.IterationCount"/> returns <c>10</c> and <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.ArgumentListCount"/> returns <c>3</c> then <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.TotalIterationCount"/> will return <c>30</c> because each argument list is executed 10 times.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.ArgumentListCount">
            <summary>
            The number of iterations the <see cref="T:BionicCode.Utilities.Net.Profiler"/> has run the specified operation.
            </summary>
            <value>The number of iterations (which is equivalent to the number of results) per argument list.</value>
            <remarks>Using the profiler with annotations (attributes) allows to specify argument lists to simulate real-world behavior where usually the values of the arguments that are provided to the member change.
            <br/>A member is executed and profiled with each argument list for the number of the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.IterationCount"/> times.
            <br/>For example if a method is profiled with three argument lists and an iteration count of 10, the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.IterationCount"/> will return <c>10</c> and the total iterations run for the profiled member is the product of <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.IterationCount"/> and <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.ArgumentListCount"/>.</remarks>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.Results">
            <summary>
            The logged results of each iteration.
            </summary>
            <value>The read-only results of all iterations.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.TotalDuration">
            <summary>
            The total duration of all logged iterations in microseconds.
            </summary>
            <value>The sum of each duration per iteration in microseconds.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.TotalDurationConverted">
            <summary>
            The total duration of all logged iterations converted to the base unit.
            </summary>
            <value>The sum of each duration per iteration converted from microseconds to the base unit defined by the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.BaseUnit"/> property.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.AverageDuration">
            <summary>
            The average duration of all logged iterations in microseconds.
            </summary>
            <value>The average duration of all iterations in microseconds.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.AverageDurationConverted">
            <summary>
            The average duration of all logged iterations converted to the base unit.
            </summary>
            <value>The average duration of all iterations converted from microseconds to the base unit defined by the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.BaseUnit"/> property.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.Range">
            <summary>
            The range of all logged iterations in microseconds.
            </summary>
            <value>The range of all iterations in microseconds.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.RangeConverted">
            <summary>
            The range of all logged iterations converted to the base unit.
            </summary>
            <value>The range of all iterations converted from microseconds to the base unit defined by the <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.BaseUnit"/> property.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.Summary">
            <summary>
            A report of the benchmarking ready for output, formatted as follows:
            
            <br/>
            <code>
                      ╭───────────────┬────────────────────────────┬────────────────╮
                      | Iteration #   │ Duration [ms]              │ Is cancelled   |
                      ┝━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━━━━━━━━━━━━━┿━━━━━━━━━━━━━━━━┥
                      │ 1             │                     1.0512 │ False          |
                      │ 2             │                     1.0020 │ False          │
                      │ 3             │                     0.8732 │ False          │
                      │ 4             │                     0.0258 │ True (ignored) │
                      │ 5             │                     0.9943 │ False          │
            ╭═════════╧═══════════════╪════════════════════════════┼────────────────┤
            │ Total:    -             │                     3.9207 │                │
            │ Min:      3             │                     0.8732 │                │
            │ Max:      1             │                     1.0512 │                │
            │ Average:  -             │                     0.9802 │                │
            ╰─────────────────────────┴────────────────────────────┴────────────────╯
            </code>
            </summary>
            <value>A formatted string that presents the results of the benchmarking in an Unicode formatted table.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.MinResult">
            <summary>
            The smallest <see cref="T:BionicCode.Utilities.Net.ProfilerResult"/> result of the batch run (which is the fastest).
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.MaxResult">
            <summary>
            The greatest <see cref="T:BionicCode.Utilities.Net.ProfilerResult"/> result of the batch run (which is the slowest).
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.TimeStamp">
            <summary>
            The timestamp that describes the moment in time the profiling session associated with this current result was executed.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.Context">
            <summary>
            Describes the context that the profiler was executed.
            </summary>
            <remarks>The context describes machine atributes like core clock and core count to help to compare results from sessions on different machines.</remarks>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResult.BaseUnit">
            <summary>
            The base unit used to calculate the values for <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.TotalDurationConverted"/>, <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.StandardDeviationConverted"/> and <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.AverageDurationConverted"/>.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.ProfilerBatchResultGroup">
            <summary>
            A list to hold a collection of <see cref="T:BionicCode.Utilities.Net.ProfilerBatchResult"/> items.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResultGroup.ProfiledTargetType">
            <summary>
            Describes the profiled member that the <see cref="T:BionicCode.Utilities.Net.ProfilerBatchResult"/> items represent.
            </summary>
            <value>The value can differ from the value of the indivudual items. 
            <br/>For example, this collection will have the value <see cref="F:BionicCode.Utilities.Net.ProfiledTargetType.Property"/> while the actual <see cref="P:BionicCode.Utilities.Net.ProfilerBatchResult.Context"/> has <see cref="P:BionicCode.Utilities.Net.ProfilerContext.TargetType"/> return <see cref="F:BionicCode.Utilities.Net.ProfiledTargetType.PropertyGet"/> and <see cref="F:BionicCode.Utilities.Net.ProfiledTargetType.PropertySet"/>.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResultGroup.ProfiledTargetSignatureMemberName">
            <summary>
            The signature name of the profiled type member.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerBatchResultGroup.ProfiledTargetMemberShortName">
            <summary>
            The signature name of the profiled type member.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.ProfilerBuilder">
            <summary>
            Class to configure the <see cref="T:BionicCode.Utilities.Net.Profiler"/> when used with annotated profiling. Call <see cref="M:BionicCode.Utilities.Net.Profiler.CreateProfilerBuilder``1"/> to obtain an instance.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerBuilder.SetIterations(System.Int32)">
            <summary>
            Set a log delegate that allows to output the result to a sink, e.g. a file or application logger.
            </summary>
            <param name="iterations">The number of iterations to perform when executing the target code. The default is <c>1</c>.</param>
            <returns>
            The currently configured <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/> instance to enable to chain calls.
            </returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerBuilder.SetBaseUnit(BionicCode.Utilities.Net.TimeUnit)">
            <summary>
            Set the time unit that the results are converted to.
            </summary>
            <param name="timeUnit">The unit that all result related time ispresented in. The default is <see cref="F:BionicCode.Utilities.Net.TimeUnit.Microseconds"/>.</param>
            <returns>
            The currently configured <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/> instance to enable to chain calls.
            </returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerBuilder.SetLogger(BionicCode.Utilities.Net.ProfilerLoggerDelegate)">
            <summary>
            Set a log delegate that allows to output the result to a sink, e.g. a file or application logger.
            </summary>
            <param name="profilerLogger">A delegate that is invoked by profiler to pass in the result.</param>
            <returns>
            The currently configured <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/> instance to enable to chain calls.
            </returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerBuilder.SetAsyncLogger(BionicCode.Utilities.Net.ProfilerLoggerAsyncDelegate)">
            <summary>
            Set a log delegate that allows to asynchronously output the result to a sink, e.g. a file or application logger.
            </summary>
            <param name="profilerLogger">An asynchronous delegate that is invoked by profiler to pass in the result.</param>
            <returns>
            The currently configured <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/> instance to enable to chain calls.
            </returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerBuilder.EnableWarmup(System.Int32)">
            <summary>
            Enable warm up iterations to trigger the JIT compiler. Warm up is enabled by default.
            </summary>
            <param name="warmupIterations">The number of iterations to perform before starting the profiling. The default is <c>4</c>.</param>
            <returns>
            The currently configured <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/> instance to enable to chain calls.
            </returns>
            <remarks>When running code the first time there is always the incurrence of the JIT to compile the code. 
            <br/>For this reason it is recommended to execute the code at least once in order to avoid the JIT to impact the profiling.
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerBuilder.DisableWarmup">
            <summary>
            Disable warm up iterations. Warm up iterations can be scheduled to trigger the JIT compiler. Warm up is enabled by default.
            </summary>
            <returns>The currently configured <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/> instance to enable to chain calls.</returns>
            <remarks>When running code the first time there is always the incurrence of the JIT to compile the code. 
            <br/>For this reason it is recommended to execute the code at least once in order to avoid the JIT to impact the profiling.
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerBuilder.EnableDefaultLogOutput">
            <summary>
            Enable default log output. The default is enabled.
            </summary>
            <returns>
            The currently configured <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/> instance to enable to chain calls.
            </returns>
            <remarks>Enables to print the profiler results to a HTML document that will be automatically displayed in the default browser. 
            <br/>A second output sink is the default Output console window of Visual Studio, but only when in debug mode.
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerBuilder.DisableDefaultLogOutput">
            <summary>
            Disable default log output.
            </summary>
            <returns>The currently configured <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/> instance to enable to chain calls.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerBuilder.SetWarmupIterations(System.Int32)">
            <summary>
            Enable warm up iterations to trigger the JIT compiler. Warm up is enabled by default.
            </summary>
            <param name="warmupIterations">The number of iterations to perform before starting the profiling. The default is <c>4</c>.</param>
            <returns>
            The currently configured <see cref="T:BionicCode.Utilities.Net.ProfilerBuilder"/> instance to enable to chain calls.
            </returns>
            <remarks>When running code the first time there is always the incurrence of the JIT to compile the code. 
            <br/>For this reason it is recommended to execute the code at least once in order to avoid the JIT to impact the profiling.
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerBuilder.RunAsync(System.Threading.CancellationToken)">
            <summary>
            Execute the profiler using the current configuration.
            </summary>
            <returns>
            A collection of <see cref="T:BionicCode.Utilities.Net.ProfilerBatchResult"/> items where each <see cref="T:BionicCode.Utilities.Net.ProfilerBatchResult"/> holds the result of a particular profiled target to accumulate the individual <see cref="T:BionicCode.Utilities.Net.ProfilerResult"/> items for each iteration.
            </returns>
        </member>
        <member name="T:BionicCode.Utilities.Net.ProfilerOptions">
            <summary>
            Configures the <see cref="T:BionicCode.Utilities.Net.Profiler"/>.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerOptions.#ctor">
            <summary>
            Default constructor.
            </summary>
            <remarks>
            Initializes the instance with 100 iterations, and the default number of warmup iteration (defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultWarmupCount"/>) and with the default time unit (defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultBaseUnit"/>).
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerOptions.#ctor(System.Int32,System.Int32,BionicCode.Utilities.Net.ProfilerLoggerDelegate,BionicCode.Utilities.Net.TimeUnit)">
            <summary>
            Constructor.
            </summary>
            <param name="iterations">The number of iterations to execute the profiled code.</param>
            <param name="warmupIterations">The number of warmup iterations.</param>
            <param name="logger">A synchronous logging delegate.</param>
            <param name="baseUnit">The desired base unit.</param>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerOptions.Iterations">
            <summary>
            The number of iterations that the profiled code is executed.
            </summary>
            <value>
            An integer number greater than <c>0</c> or <c>0</c> to perform no profiling. The <see cref="T:BionicCode.Utilities.Net.Profiler"/> will throw an exception if the value is less than <c>0</c>. The default is defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultIterationCount"/>.
            </value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerOptions.WarmupIterations">
            <summary>
            The number of iterations that the profiled code is executed before the actual profiling.
            </summary>
            <value> 
            An integer number greater than <c>0</c> or <c>0</c> to perform no warmup (cold start). The <see cref="T:BionicCode.Utilities.Net.Profiler"/> will throw an exception if the value is less than <c>0</c>.  default is defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultWarmupCount"/>.
            </value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerOptions.Logger">
            <summary>
            A delegate to handle the result.
            </summary>
            <remarks>
            Use the async API of the <see cref="T:BionicCode.Utilities.Net.Profiler"/> if you need to define an async delegate.
            </remarks>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerOptions.BaseUnit">
            <summary>
            The default base unit that all results are transformed to.
            </summary>
            <remarks>
            Internally time is recorded in microseconds and then converted to the desired base unit (e.g., ms). The usual timer resolution on most modern machines is 100 ns (see <see cref="P:System.TimeSpan.Ticks"/> to learn more. Call the static <see cref="F:System.Diagnostics.Stopwatch.IsHighResolution"/> field to know if the executing machine supports that high resolution.)
            </remarks>
            <value>
            The default is defined by <see cref="F:BionicCode.Utilities.Net.Profiler.DefaultBaseUnit"/>.
            </value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerOptions.Runtime">
            <summary>
            Defines the environment that the profiled code is executed in.
            </summary>
            <value>The desired runtime. The default is <see cref="F:BionicCode.Utilities.Net.Runtime.Default"/> which evaluates to the highest supported .NET version. 
            <br/>See <see cref="P:BionicCode.Utilities.Net.ProfilerOptions.Runtime"/> to know the currently supported runtimes.</value>
        </member>
        <member name="T:BionicCode.Utilities.Net.ProfilerResult">
            <summary>
            The result of a single benchmark run or iteration.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerResult.ElapsedTime">
            <summary>
            The duration of the benchmark run in microseconds.
            </summary>
            <value>The duration in microseconds.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerResult.ElapsedTimeConverted">
            <summary>
            The duration of the benchmark run converted to the base unit.
            </summary>
            <value>The duration converted from microseconds to the base unit defined by the <see cref="P:BionicCode.Utilities.Net.ProfilerResult.BaseUnit"/> property.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerResult.Deviation">
            <summary>
            The deviation from the arithmetic mean in microseconds.
            </summary>
            <value>A positive or negative value to describe the deviation from the arithmetic mean in microseconds.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerResult.DeviationConverted">
            <summary>
            The deviation from the arithmetic mean converted to the base unit.
            </summary>
            <value>A positive or negative value to describe the deviation from the arithmetic mean. the value is converted from microseconds to the base unit defined by the <see cref="P:BionicCode.Utilities.Net.ProfilerResult.BaseUnit"/> property.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerResult.BaseUnit">
            <summary>
            The base unit used to calculate the values for <see cref="P:BionicCode.Utilities.Net.ProfilerResult.DeviationConverted"/> and <see cref="P:BionicCode.Utilities.Net.ProfilerResult.ElapsedTimeConverted"/>.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerResult.IsProfiledTaskCancelled">
            <summary>
            In case the benchmarked operation is an async method, <see cref="P:BionicCode.Utilities.Net.ProfilerResult.IsProfiledTaskCancelled"/> indiocates wwhether the <see langword="async"/>operation was cancelled or not.
            </summary>
            <value><see langword="true"/> in case the operation wwwas cancelled (and the <see cref="P:BionicCode.Utilities.Net.ProfilerResult.ProfiledTask"/> result is in a canlled state (<see cref="P:System.Threading.Tasks.Task.Status"/> returns <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/>).</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerResult.Iteration">
            <summary>
            In case of a multi-run benchmark run (e.g. by calling <see cref="!:Profiler.LogTime(Action, int, TimeUnit, string, int)"/>), the property <see cref="P:BionicCode.Utilities.Net.ProfilerResult.Iteration"/> returns the run's actual number the <see cref="T:BionicCode.Utilities.Net.ProfilerResult"/> is associated with.
            </summary>
            <value>The number of the run the <see cref="T:BionicCode.Utilities.Net.ProfilerResult"/> is associated with. Otherwise <c>-1</c>.</value>
            <remarks>
            In case of a attributed benchmark run (e.g. by calling <see cref="M:BionicCode.Utilities.Net.Profiler.CreateProfilerBuilder(System.Type)"/>), the property <see cref="P:BionicCode.Utilities.Net.ProfilerResult.Iteration"/> returns the number of runs for each argument list (defined using the <see cref="T:BionicCode.Utilities.Net.ProfilerArgumentAttribute"/> attribute) 
            <br/>and the <see cref="P:BionicCode.Utilities.Net.ProfilerResult.ArgumentListIndex"/> property returns the index of the argument list that the <see cref="T:BionicCode.Utilities.Net.ProfilerResult"/> is associated with.
            </remarks>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerResult.ArgumentListIndex">
            <summary>
            In case of a attributed benchmark run (e.g. by calling <see cref="M:BionicCode.Utilities.Net.Profiler.CreateProfilerBuilder(System.Type)"/>), the property returns the index of the argument list the <see cref="T:BionicCode.Utilities.Net.ProfilerResult"/> is associated with.
            </summary>
            <value>The index of the argument list the <see cref="T:BionicCode.Utilities.Net.ProfilerResult"/> is associated with. Otherwise <c>-1</c>.</value>
            <remarks>
            In case of a attributed benchmark run (e.g. by calling <see cref="M:BionicCode.Utilities.Net.Profiler.CreateProfilerBuilder(System.Type)"/>), the property <see cref="P:BionicCode.Utilities.Net.ProfilerResult.Iteration"/> returns the number of runs for each argument list (defined using the <see cref="T:BionicCode.Utilities.Net.ProfilerArgumentAttribute"/> attribute) 
            <br/>and the <see cref="P:BionicCode.Utilities.Net.ProfilerResult.ArgumentListIndex"/> property returns the index of the argument list that the <see cref="T:BionicCode.Utilities.Net.ProfilerResult"/> is associated with.
            </remarks>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProfilerResult.ProfiledTask">
            <summary>
            The <see cref="T:System.Threading.Tasks.Task"/> returned from the async operation that was benchmarked.
            </summary>
            <value>The <see cref="T:System.Threading.Tasks.Task"/> result.</value>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerResult.CompareTo(BionicCode.Utilities.Net.ProfilerResult)">
            <inheritdoc/>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerResult.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerResult.Equals(BionicCode.Utilities.Net.ProfilerResult)">
            <inheritdoc/>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProfilerResult.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:BionicCode.Utilities.Net.Runtime">
            <summary>
            Used to specify the environment that the <see cref="T:BionicCode.Utilities.Net.Profiler"/> should use to profile the code.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.ReflectionHelper">
            <summary>
            A set of helpers to simplify some reflection tasks.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.ReflectionHelper.GetCurrentMemberName(System.String)">
            <summary>
            A convenient helper to return the member name of the current context without the need to decorate the member with the <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/> attribute.
            </summary>
            <param name="callerMemberName">The member name (optional and not required).</param>
            <returns>The member name of the current context.</returns>
            <remarks>Passing a <paramref name="callerMemberName"/> argument is not required as thie value is actually retrieved via refelection.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ReflectionHelper.GetCurrentFilePath(System.String)">
            <summary>
            A convenient helper to return the file path of the source file that contains the current caller context without the need to decorate the member with the <see cref="T:System.Runtime.CompilerServices.CallerFilePathAttribute"/> attribute.
            </summary>
            <param name="callerFilePath">The file path (optional and not required).</param>
            <returns>The file path of the source file that contains the current context.</returns>
            <remarks>Passing a <paramref name="callerFilePath"/> argument is not required as thie value is actually retrieved via refelection.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ReflectionHelper.GetCurrentLineNumber(System.Int32)">
            <summary>
            A convenient helper to return the line number of the caller at which the current context was called without the need to decorate the member with the <see cref="T:System.Runtime.CompilerServices.CallerLineNumberAttribute"/> attribute.
            </summary>
            <param name="callerLineNumber">The line number (optional and not required).</param>
            <returns>The line number of the caller at which the current context was called.</returns>
            <remarks>Passing a <paramref name="callerLineNumber"/> argument is not required as thie value is actually retrieved via refelection.</remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_LessThan(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_GreaterThan(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_LessThan(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_GreaterThan(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_LessThan(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_GreaterThan(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_LessThan(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_GreaterThan(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_LessThan(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_LessThanOrEqual(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_LessThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_GreaterThan(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThan(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_GreaterThanOrEqual(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IComparisonOperators&lt;TSelf, TOther, TResult&gt;.op_GreaterThanOrEqual(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Multiply(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Division(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Multiply(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Division(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Multiply(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Division(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Multiply(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Division(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Multiply(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Division(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Multiply(BionicCode.Utilities.Net.Seconds,System.Double)">
            <inheritdoc cref="!:System.Numerics.IMultiplyOperators&lt;TSelf, TOther, TResult&gt;.op_Multiply(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Division(BionicCode.Utilities.Net.Seconds,System.Double)">
            <inheritdoc cref="!:System.Numerics.IDivisionOperators&lt;TSelf, TOther, TResult&gt;.op_Division(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Equality(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Inequality(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Minutes)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Equality(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Inequality(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Seconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Equality(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Inequality(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Milliseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Equality(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Inequality(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Microseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Equality(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Equality(TSelf, TOther)" />
        </member>
        <member name="M:BionicCode.Utilities.Net.Seconds.op_Inequality(BionicCode.Utilities.Net.Seconds,BionicCode.Utilities.Net.Nanoseconds)">
            <inheritdoc cref="!:System.Numerics.IEqualityOperators&lt;TSelf, TOther, TResult&gt;.op_Inequality(TSelf, TOther)" />
        </member>
        <member name="T:BionicCode.Utilities.Net.IProgressReporterCommon">
            <summary>
            Interface to provide progress properties to be exposed by a view model for data binding a progress reporter GUI control.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.IProgressReporterCommon.CreateProgressReporterFromCurrentThread">
            <summary>
            Creates a <see cref="T:System.IProgress`1"/> instance that is associated with the caller's thread.
            The registered progress callback is the virtual <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.OnProgress(BionicCode.Utilities.Net.ProgressData)" /> member.
            </summary>
            <remarks>To create a <see cref="T:System.IProgress`1"/> instance that is associated with the application's primary dispatcher thread, for example to update proreties that bind to a <c>DispatcherObject</c>, call <see href="https://sampoh.de/github/docs/bioniccode.net/api/BionicCode.Utilities.Net.IProgressReporter.html#BionicCode_Utilities_Net_IProgressReporter_CreateProgressReporterFromUiThread">IProgressReporter.CreateProgressReporterFromUiThread</see>.</remarks>
            <returns>A <see cref="T:System.IProgress`1"/> instance that posts progress to the thread <see cref="M:BionicCode.Utilities.Net.IProgressReporterCommon.CreateProgressReporterFromCurrentThread"/> was called from.</returns>
        </member>
        <member name="P:BionicCode.Utilities.Net.IProgressReporterCommon.IsReportingProgress">
            <summary>
            Indicates ongoing progress reporting 
            </summary>
            <remarks>Raises <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event.</remarks>
        </member>
        <member name="P:BionicCode.Utilities.Net.IProgressReporterCommon.IsIndeterminate">
            <summary>
            Indicates that the progress reporting is indeterminate.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.IProgressReporterCommon.ProgressText">
            <summary>
            The progress message.
            </summary>
            <remarks>Raises <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event.</remarks>
        </member>
        <member name="P:BionicCode.Utilities.Net.IProgressReporterCommon.ProgressValue">
            <summary>
            The progress value.
            </summary>
            <remarks>Raises <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event.</remarks>
        </member>
        <member name="E:BionicCode.Utilities.Net.IProgressReporterCommon.ProgressChanged">
            <summary>
            Raised when <see cref="P:BionicCode.Utilities.Net.IProgressReporterCommon.ProgressValue"/>, <see cref="P:BionicCode.Utilities.Net.IProgressReporterCommon.ProgressText"/> or <see cref="P:BionicCode.Utilities.Net.IProgressReporterCommon.IsIndeterminate"/> has changed.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.IViewModelCommon">
            <summary>
            Encapsulates implementations of <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> and <see cref="T:System.ComponentModel.INotifyDataErrorInfo"/> and adds <see cref="E:BionicCode.Utilities.Net.IViewModelCommon.PropertyValueChanged"/> event which is raised in tandem with <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> except it provides addition data like old value and new value.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.IViewModelCommon.PropertyHasError(System.String)">
            <summary>
            Checks whether the specified property has errors or is valid.
            </summary>
            <param name="propertyName">The name of the property to check for errors.</param>
            <returns><c>true</c> when the specified property has at least one error. Otherwise <c>false</c> when the property is valid.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.IViewModelCommon.GetPropertyErrors(System.String)">
            <summary>
            Gets all error messages of the specified property. If the <paramref name="propertyName"/> is <c>null</c> all error messages will be returned.
            </summary>
            <param name="propertyName">The of the property of which the error messages should be returned.</param>
            <returns>Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> containing all error messages of the specified property.</returns>
            <remarks>If the <paramref name="propertyName"/> is <c>null</c> all current error messages will be returned.</remarks>
        </member>
        <member name="E:BionicCode.Utilities.Net.IViewModelCommon.PropertyValueChanged">
            <summary>
            PropertyChanged implementation that sends old value and new value of the change and raises the INotifyPropertyChanged event.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.ProgressChangedEventArgs">
            <summary>
            Event args for the <see cref="T:BionicCode.Utilities.Net.ProgressChangedEventHandler"/>.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProgressChangedEventArgs.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProgressChangedEventArgs.#ctor(System.Double,System.Double)">
            <summary>
            Constructor.
            </summary>
            <param name="oldValue">The old progress value before the change.</param>
            <param name="newValue">The new progress value after the change.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProgressChangedEventArgs.#ctor(System.Double,System.Double,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="oldValue">The old progress value before the change.</param>
            <param name="newValue">The new progress value after the change.</param>
            <param name="progressText">A text message to summarize the progress.</param>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProgressChangedEventArgs.OldValue">
            <summary>
            The old progress value before the change.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProgressChangedEventArgs.NewValue">
            <summary>
            The new progress value after the change.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProgressChangedEventArgs.ProgressText">
            <summary>
            A text message to summarize the progress.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProgressChangedEventArgs.IsIndeterminate">
            <summary>
            Indicates that the progress is indeterminate what would characterize the progress values of <see cref="P:BionicCode.Utilities.Net.ProgressChangedEventArgs.OldValue"/> and <see cref="P:BionicCode.Utilities.Net.ProgressChangedEventArgs.NewValue"/> just random progress e.g. bytes transferred instead of an abslote value of a fixed value range.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.ProgressData.#ctor(System.String,System.Double)">
            <summary>
            Data model to report progress to a implementation of <see cref="T:BionicCode.Utilities.Net.IProgressReporterCommon"/>. When using the <see cref="T:System.IProgress`1"/> returned from the <see cref="M:BionicCode.Utilities.Net.IProgressReporterCommon.CreateProgressReporterFromCurrentThread"/> method, the <see cref="T:BionicCode.Utilities.Net.ProgressData"/> serves as the argument.
            </summary>
            <param name="message">A progress message.</param>
            <param name="progress">The progress value.</param>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProgressData.Message">
            <summary>
            The progress message text.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.ProgressData.Progress">
            <summary>
            The progress value.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.PropertyValidationResult">
            <summary>
            The result that must be returned from a custom validation delegate tha matches the <see cref="T:BionicCode.Utilities.Net.PropertyValidationDelegate`1"/> delegate.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.PropertyValidationResult.#ctor(System.Boolean,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Constructor.
            </summary>
            <param name="isValid"><c>true</c> when the validation has successfully passed. <c>false</c> when the validation has failed.</param>
            <param name="errorMessages">A collection of error messasge objects that can be displayed in the UI. It's expected that the client will generate one message for each validation error of the currently validated property.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.PropertyValidationResult.#ctor(System.Boolean,System.Object)">
            <summary>
            Constructor.
            </summary>
            <param name="isValid"><c>true</c> when the validation has successfully passed. <c>false</c> when the validation has failed.</param>
            <param name="errorMessage">An error messasge object that can be displayed in the UI.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.PropertyValidationResult.Deconstruct(System.Boolean@,System.Collections.Generic.IEnumerable{System.Object}@)">
            <summary>
            Deconstructor.
            </summary>
            <param name="isValid"></param>
            <param name="errorMessages"></param>
            <remarks>This deconstructor was mainly introduced to suppport backwards compatibility withlegacy versions where the delegate was returning a <c>ValueTuple</c>.</remarks>
        </member>
        <member name="P:BionicCode.Utilities.Net.PropertyValidationResult.IsValid">
            <summary>
            Returns whether tha validation was successful or has failed.
            </summary>
            <value><c>true</c> when the validation has successfully passed. <c>false</c> when the validation has failed.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.PropertyValidationResult.ErrorMessages">
            <summary>
            A collection of error message objects. 
            </summary>
            <value>It usually contains one message for each property error.</value>
        </member>
        <member name="T:BionicCode.Utilities.Net.PropertyValueChangedArgs`1">
            <summary>
            Event args fro the <see cref="T:BionicCode.Utilities.Net.PropertyValueChangedEventHandler`1"/> event delegate.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:BionicCode.Utilities.Net.PropertyValueChangedArgs`1.#ctor(System.String,`0,`0)">
            <summary>
            Constructor.
            </summary>
            <param name="propertyName">The name of the changed property.</param>
            <param name="oldValue">The value before the change.</param>
            <param name="newValue">The value that caused the change.</param>
        </member>
        <member name="P:BionicCode.Utilities.Net.PropertyValueChangedArgs`1.PropertyName">
            <summary>
            Read-only property holding the property's name.
            </summary>
            <value>The name of the changed property.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.PropertyValueChangedArgs`1.OldValue">
            <summary>
            Read-only property holding the value before the change.
            </summary>
            <value>The value before the change.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.PropertyValueChangedArgs`1.NewValue">
            <summary>
            Read-only property holding the value after the change.
            </summary>
            <value>The value after the change.</value>
        </member>
        <member name="T:BionicCode.Utilities.Net.ViewModelCommon">
            <summary>
            Base class recommended to use for view models across the application. Encapsulates implementations of <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> and <see cref="T:System.ComponentModel.INotifyDataErrorInfo"/>.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions">
            <summary>
            Configuration objectect to configure the behavior of the property set methods.
            </summary>
        </member>
        <member name="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.Default">
            <summary>
             Gets the default behavior for the property set methods. <br/>By default the configuration sets <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c>, <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>false</c> and <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectInvalidValueEnabled"/> to <c>false</c>.
            </summary>
            <value>An instance configured with the default values.</value>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.#ctor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="isRejectInvalidValueEnabled">Controls how the invalid property value is stored. Use this to ensure that the view model in a valid state. See <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectInvalidValueEnabled"/>.</param>
            <param name="isThrowExceptionOnValidationErrorEnable">Controls if throwing an <exception cref="T:System.ArgumentException"></exception> on a failed validation is enabled. See <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/>.</param>
            <param name="isRejectEqualValuesEnabled">Controls if the equality check before setting the value is enabled. See <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/>.</param>
        </member>
        <member name="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectInvalidValueEnabled">
            <summary>
            Gets how the invalid property value is stored. Use this to ensure that the view model in a valid state.
            </summary>
            <value>If <c>true</c> the invalid value is not stored to the backing field.<br/> The default is <c>false</c>.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled">
            <summary>
            Gets if throwing an <exception cref="T:System.ArgumentException"></exception> on a failed validation is enabled. 
            <br/>Use this when <c>ValidatesOnExceptions</c> on a <c>Binding</c> is set to <c>true</c>
            </summary>
            <value><c>true</c> if throwing an <exception cref="T:System.ArgumentException"></exception> on a failed validation is enabled. Otherwise <c>false</c>. 
            <br/>The default is <c>false</c>.</value>
        </member>
        <member name="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled">
            <summary>
            Gets if the equality check before setting the value is enabled.
            </summary>
            <value>If <c>true</c> the equality check before setting the value to avoid raising the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event on equality is enabled. If <c>false</c> equality check is deisabled. This will always raise the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event.
            <br/>the default is <c>true</c>.</value>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,``0@,System.String)">
            <summary>
            Generic property setter. Sets the value of any property of the extending view model by passing in a the corresponding property backing field. Automatically raises the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for this property.
            </summary>
            <remarks>Equality checking is enabled by default and must be explicitly disabled if needed by passing a <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> to the appropriate overload. To determine equality <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> is called. <br/>This means when the new property value <paramref name="value"/> equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>To change the equality definition use an overload that accepts an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> (for example <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,``0@,System.Collections.Generic.IEqualityComparer{``0},System.String)"/>). 
            <para>To validate the <paramref name="value"/>, use the <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,System.Func{``0,System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}},``0@,BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)"/>  method.
            <br/>For asynchronous validation use the <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueAsync``1(``0,``0,System.Func{``0,System.Threading.Tasks.Task{System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}}},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)"/> method.</para>
            </remarks>
            <typeparam name="TValue">The generic type parameter of the new property value.</typeparam>
            <param name="value">The new property value.</param>
            <param name="targetBackingField">The backing field of the target property for the new value. Passed in by reference using <c>ref</c> keyword.</param>
            <param name="propertyName">The name of the property that changes. By default the property name is automatically set to the property that called this setter method.</param>
            <returns><c>true</c> when the property has changed or <c>false</c> when equality checking is enabled and the new property equals the old property value.</returns>    
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,``0@,BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.String)">
            <summary>
            Generic property setter. Sets the value of any property of the extending view model by passing in a the corresponding property backing field. Automatically raises the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for this property.
            </summary>
            <remarks>Equality checking is enabled by default and must be explicitly disabled if needed by passing a <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> to the appropriate overload. To determine equality <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> is called. <br/>This means when the new property value <paramref name="value"/> equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>To change the equality definition use an overload that accepts an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> (for example <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,``0@,System.Collections.Generic.IEqualityComparer{``0},System.String)"/>). 
            <para>To validate the <paramref name="value"/>, use the <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,System.Func{``0,System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}},``0@,BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)"/>  method.
            <br/>For asynchronous validation use the <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueAsync``1(``0,``0,System.Func{``0,System.Threading.Tasks.Task{System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}}},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)"/> method.</para>
            </remarks>
            <typeparam name="TValue">The generic type parameter of the new property value.</typeparam>
            <param name="value">The new property value.</param>
            <param name="targetBackingField">The backing field of the target property for the new value. Passed in by reference using <c>ref</c> keyword.</param>    
            <param name="methodConfiguration">Use to configure the method's behavior.</param>
            <param name="propertyName">The name of the property that changes. By default the property name is automatically set to the property that called this setter method.</param>
            <returns><c>true</c> when the property has changed or <c>false</c> when equality checking is enabled and the new property equals the old property value.</returns>    
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,``0@,System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
            Generic property setter. Sets the value of any property of the extending view model by passing in a the corresponding property backing field. Automatically raises the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for this property.
            </summary>
            <remarks>Equality checking is enabled by default and must be explicitly disabled if needed by passing a <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> to the appropriate overload. To determine equality <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> is called. <br/>This means when the new property value <paramref name="value"/> equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. If equality checking is enabled and no <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> was provided by setting the <paramref name="equalityComparer"/> parameter or the value is <c>NULL</c>, 
            the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>To validate the <paramref name="value"/>, use the <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,System.Func{``0,System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}},``0@,BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)"/>  method.
            <br/>For asynchronous validation use the <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueAsync``1(``0,``0,System.Func{``0,System.Threading.Tasks.Task{System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}}},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)"/> method.</para>
            </remarks>
            <typeparam name="TValue">The generic type parameter of the new property value.</typeparam>
            <param name="value">The new property value.</param>
            <param name="targetBackingField">The backing field of the target property for the new value. Passed in by reference using <c>ref</c> keyword.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. 
            <br/>Passing in an <see cref="T:System.Collections.IEqualityComparer"/> automatically enables value rejection in case the equality test succeeds (new value and old value are equal). If <paramref name="equalityComparer"/> is <c>>NULL</c> <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used to test for equality.</param>
            <param name="propertyName">The name of the property that changes. By default the property name is automatically set to the property that called this setter method.</param>
            <returns><c>true</c> when the property has changed or <c>false</c> when equality checking is enabled and the new property equals the old property value.</returns>    
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,``0@,System.Collections.Generic.IEqualityComparer{``0},BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.String)">
            <summary>
            Generic property setter. Sets the value of any property of the extending view model by passing in a the corresponding property backing field. Automatically raises the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for this property.
            </summary>
            <remarks>Equality checking is enabled by default and must be explicitly disabled if needed by passing a <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> to the appropriate overload. To determine equality <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> is called. <br/>This means when the new property value <paramref name="value"/> equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. If equality checking is enabled and no <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> was provided by setting the <paramref name="equalityComparer"/> parameter or the value is <c>NULL</c>, 
            the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>To validate the <paramref name="value"/>, use the <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,System.Func{``0,System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}},``0@,BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)"/>  method.
            <br/>For asynchronous validation use the <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueAsync``1(``0,``0,System.Func{``0,System.Threading.Tasks.Task{System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}}},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)"/> method.</para>
            </remarks>
            <typeparam name="TValue">The generic type parameter of the new property value.</typeparam>
            <param name="value">The new property value.</param>
            <param name="targetBackingField">The backing field of the target property for the new value. Passed in by reference using <c>ref</c> keyword.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. 
            <br/>Passing in an <see cref="T:System.Collections.IEqualityComparer"/> automatically enables value rejection in case the equality test succeeds (new value and old value are equal). If <paramref name="equalityComparer"/> is <c>>NULL</c> <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used to test for equality.</param>
            <param name="methodConfiguration">Use to configure the method's behavior.</param>
            <param name="propertyName">The name of the property that changes. By default the property name is automatically set to the property that called this setter method.</param>
            <returns><c>true</c> when the property has changed or <c>false</c> when equality checking is enabled and the new property equals the old property value.</returns>    
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,System.Func{``0,System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}},``0@,System.String)">
            <summary>
             Sets the value of the referenced property and executes a validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="value">The new value which is to be set to the property.</param>
            <param name="validationDelegate">The callback that is used to validate the new value.</param>
            <param name="targetBackingField">The reference to the backing field.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>If the value is <c>NULL</c> the validation delegate <paramref name="validationDelegate"/> is executed and the related method result is returned but a validation error is not recorded.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="validationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="validationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>NULL</c>, the <paramref name="value"/> is validated without generating an error. This is because validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,BionicCode.Utilities.Net.PropertyValidationDelegate{``0},``0@,System.String)">
            <summary>
             Sets the value of the referenced property and executes a validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="value">The new value which is to be set to the property.</param>
            <param name="validationDelegate">The callback that is used to validate the new value.</param>
            <param name="targetBackingField">The reference to the backing field.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>If the value is <c>NULL</c> the validation delegate <paramref name="validationDelegate"/> is executed and the related method result is returned but a validation error is not recorded.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="validationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="validationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>NULL</c>, the <paramref name="value"/> is validated without generating an error. This is because validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,System.Func{``0,System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}},``0@,BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.String)">
            <summary>
             Sets the value of the referenced property and executes a validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="value">The new value which is to be set to the property.</param>
            <param name="validationDelegate">The callback that is used to validate the new value.</param>
            <param name="targetBackingField">The reference to the backing field.</param>
            <param name="methodConfiguration">A <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> object to configure the behavior of the method.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>If the value is <c>NULL</c> the validation delegate <paramref name="validationDelegate"/> is executed and the related method result is returned but a validation error is not recorded.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="validationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="validationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c> and the feature is always enabled by default) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>NULL</c>, the <paramref name="value"/> is validated without generating an error. This is because validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,BionicCode.Utilities.Net.PropertyValidationDelegate{``0},``0@,BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.String)">
            <summary>
             Sets the value of the referenced property and executes a validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="value">The new value which is to be set to the property.</param>
            <param name="validationDelegate">The callback that is used to validate the new value.</param>
            <param name="targetBackingField">The reference to the backing field.</param>
            <param name="methodConfiguration">A <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> object to configure the behavior of the method.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>If the value is <c>NULL</c> the validation delegate <paramref name="validationDelegate"/> is executed and the related method result is returned but a validation error is not recorded.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="validationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="validationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c> and the feature is always enabled by default) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>NULL</c>, the <paramref name="value"/> is validated without generating an error. This is because validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,System.Func{``0,System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}},``0@,BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
             Sets the value of the referenced property and executes a validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="value">The new value which is to be set to the property.</param>
            <param name="validationDelegate">The callback that is used to validate the new value.</param>
            <param name="targetBackingField">The reference to the backing field.</param>
            <param name="methodConfiguration">A <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> object to configure the behavior of the method.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>If the value is <c>NULL</c> the validation delegate <paramref name="validationDelegate"/> is executed and the related method result is returned but a validation error is not recorded.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. If this optional parameter is not provided <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="validationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="validationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c> and the feature is always enabled by default) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>If equality checking is enabled and no valid <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> was provided by setting the <paramref name="equalityComparer"/> parameter, the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>NULL</c>, the <paramref name="value"/> is validated without generating an error. This is because validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValue``1(``0,BionicCode.Utilities.Net.PropertyValidationDelegate{``0},``0@,BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
             Sets the value of the referenced property and executes a validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="value">The new value which is to be set to the property.</param>
            <param name="validationDelegate">The callback that is used to validate the new value.</param>
            <param name="targetBackingField">The reference to the backing field.</param>
            <param name="methodConfiguration">A <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> object to configure the behavior of the method.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>If the value is <c>NULL</c> the validation delegate <paramref name="validationDelegate"/> is executed and the related method result is returned but a validation error is not recorded.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. If this optional parameter is not provided <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="validationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="validationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c> and the feature is always enabled by default) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>If equality checking is enabled and no valid <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> was provided by setting the <paramref name="equalityComparer"/> parameter, the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>NULL</c>, the <paramref name="value"/> is validated without generating an error. This is because validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueAsync``1(``0,``0,System.Func{``0,System.Threading.Tasks.Task{System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}}},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},System.String)">
            <summary>
             Support for asynchronous validation. Sets the value of the referenced property and executes an asynchronous validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="newValue">The new value which is to be set to the property.</param>
            <param name="oldValue">The current value.</param>
            <param name="asyncValidationDelegate">The asynchronous callback that is used to validate the new value.</param>
            <param name="backingFieldSetterDelegate">A <see cref="T:BionicCode.Utilities.Net.SetBackingFieldDelegate`1"/>. This delegate is required to set the backing field of a property by an async method. Async methods can't define <c>ref</c> parameters.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="asyncValidationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="asyncValidationDelegate"/> return <c>true</c>.
            <br/>To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="newValue"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueAsync``1(``0,``0,System.Func{``0,System.Threading.Tasks.Task{System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}}},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.String)">
            <summary>
             Support for asynchronous validation. Sets the value of the referenced property and executes an asynchronous validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="newValue">The new value which is to be set to the property.</param>
            <param name="oldValue">The current value.</param>
            <param name="asyncValidationDelegate">The asynchronous callback that is used to validate the new value.</param>
            <param name="backingFieldSetterDelegate">A <see cref="T:BionicCode.Utilities.Net.SetBackingFieldDelegate`1"/>. This delegate is required to set the backing field of a property by an async method. Async methods can't define <c>ref</c> parameters.</param>
            <param name="methodConfiguration">A <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> object to configure the behavior of the method.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="asyncValidationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="asyncValidationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c>) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="newValue"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueAsync``1(``0,``0,System.Func{``0,System.Threading.Tasks.Task{System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}}},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
             Support for asynchronous validation. Sets the value of the referenced property and executes an asynchronous validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="newValue">The new value which is to be set to the property.</param>
            <param name="oldValue">The current value.</param>
            <param name="asyncValidationDelegate">The asynchronous callback that is used to validate the new value.</param>
            <param name="backingFieldSetterDelegate">A <see cref="T:BionicCode.Utilities.Net.SetBackingFieldDelegate`1"/>. This delegate is required to set the backing field of a property by an async method. Async methods can't define <c>ref</c> parameters.</param>
            <param name="methodConfiguration">A <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> object to configure the behavior of the method.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. If this optional parameter is not provided <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="asyncValidationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="asyncValidationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c>) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/><br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="newValue"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueAsync``1(``0,``0,BionicCode.Utilities.Net.PropertyValidationDelegateAsync{``0},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},System.String)">
            <summary>
             Support for asynchronous validation. Sets the value of the referenced property and executes an asynchronous validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="newValue">The new value which is to be set to the property.</param>
            <param name="oldValue">The current value.</param>
            <param name="asyncValidationDelegate">The asynchronous callback that is used to validate the new value.</param>
            <param name="backingFieldSetterDelegate">A <see cref="T:BionicCode.Utilities.Net.SetBackingFieldDelegate`1"/>. This delegate is required to set the backing field of a property by an async method. Async methods can't define <c>ref</c> parameters.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="asyncValidationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="asyncValidationDelegate"/> return <c>true</c>.
            <br/>To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="newValue"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueAsync``1(``0,``0,BionicCode.Utilities.Net.PropertyValidationDelegateAsync{``0},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.String)">
            <summary>
             Support for asynchronous validation. Sets the value of the referenced property and executes an asynchronous validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="newValue">The new value which is to be set to the property.</param>
            <param name="oldValue">The current value.</param>
            <param name="asyncValidationDelegate">The asynchronous callback that is used to validate the new value.</param>
            <param name="backingFieldSetterDelegate">A <see cref="T:BionicCode.Utilities.Net.SetBackingFieldDelegate`1"/>. This delegate is required to set the backing field of a property by an async method. Async methods can't define <c>ref</c> parameters.</param>
            <param name="methodConfiguration">A <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> object to configure the behavior of the method.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="asyncValidationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="asyncValidationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c>) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="newValue"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueAsync``1(``0,``0,BionicCode.Utilities.Net.PropertyValidationDelegateAsync{``0},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
             Support for asynchronous validation. Sets the value of the referenced property and executes an asynchronous validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="newValue">The new value which is to be set to the property.</param>
            <param name="oldValue">The current value.</param>
            <param name="asyncValidationDelegate">The asynchronous callback that is used to validate the new value.</param>
            <param name="backingFieldSetterDelegate">A <see cref="T:BionicCode.Utilities.Net.SetBackingFieldDelegate`1"/>. This delegate is required to set the backing field of a property by an async method. Async methods can't define <c>ref</c> parameters.</param>
            <param name="methodConfiguration">A <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> object to configure the behavior of the method.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. If this optional parameter is not provided <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="asyncValidationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="asyncValidationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c>) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="newValue"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilent``1(``0,``0@,BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
            Generic property setter. Silently sets the value of any property of the extending view model by passing in a the corresponding property backing field. Suppresses a <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for this property.
            </summary>
            <remarks>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="value"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
            <typeparam name="TValue">The generic type parameter of the new property value.</typeparam>
            <param name="value">The new property value.</param>
            <param name="targetBackingField">The backing field of the target property for the new value. Passed in by reference using <c>ref</c> keyword.</param>
            <param name="methodConfiguration">A <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> object to configure the behavior of the method.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. If this optional parameter is not provided <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used.</param>
            <param name="propertyName">The name of the property that changes. By default the property name is automatically set to the property that called this setter method.
            </param>
            <returns><c>true</c> when the property has changed or <c>false</c> when the property value didn't change (e.g. on equality of old and new value).</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilent``1(``0,``0@,BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.String)">
            <summary>
            Generic property setter. Silently sets the value of any property of the extending view model by passing in a the corresponding property backing field. Suppresses a <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for this property.
            </summary>
            <remarks>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="value"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
            <typeparam name="TValue">The generic type parameter of the new property value.</typeparam>
            <param name="value">The new property value.</param>
            <param name="targetBackingField">The backing field of the target property for the new value. Passed in by reference using <c>ref</c> keyword.</param>
            <param name="methodConfiguration">A <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> object to configure the behavior of the method.</param>
            <param name="propertyName">The name of the property that changes. By default the property name is automatically set to the property that called this setter method.
            .</param>
            <returns><c>true</c> when the property has changed or <c>false</c> when the property value didn't change (e.g. on equality of old and new value).</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilent``1(``0,``0@,System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
            Generic property setter. Silently sets the value of any property of the extending view model by passing in a the corresponding property backing field. Suppresses a <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for this property.
            </summary>
            <remarks>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="value"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
            <typeparam name="TValue">The generic type parameter of the new property value.</typeparam>
            <param name="value">The new property value.</param>
            <param name="targetBackingField">The backing field of the target property for the new value. Passed in by reference using <c>ref</c> keyword.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. If this optional parameter is not provided <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used.</param>
            <param name="propertyName">The name of the property that changes. By default the property name is automatically set to the property that called this setter method.
            </param>
            <returns><c>true</c> when the property has changed or <c>false</c> when the property value didn't change (e.g. on equality of old and new value).</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilent``1(``0,``0@,System.String)">
            <summary>
            Generic property setter. Silently sets the value of any property of the extending view model by passing in a the corresponding property backing field. Suppresses a <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event for this property.
            </summary>
            <remarks>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="value"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
            <typeparam name="TValue">The generic type parameter of the new property value.</typeparam>
            <param name="value">The new property value.</param>
            <param name="targetBackingField">The backing field of the target property for the new value. Passed in by reference using <c>ref</c> keyword.</param>
            <param name="propertyName">The name of the property that changes. By default the property name is automatically set to the property that called this setter method.
            </param>
            <returns><c>true</c> when the property has changed or <c>false</c> when the property value didn't change (e.g. on equality of old and new value).</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilent``1(``0,System.Func{``0,System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}},``0@,BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes a validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="value">The new value which is to be set to the property.</param>
            <param name="validationDelegate">The callback that is used to validate the new value.</param>
            <param name="targetBackingField">The reference to the backing field.</param>
            <param name="methodConfiguration">A <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> object to configure the behavior of the method.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. If this optional parameter is not provided <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="validationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="validationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c>) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="value"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilent``1(``0,System.Func{``0,System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}},``0@,BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes a validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="value">The new value which is to be set to the property.</param>
            <param name="validationDelegate">The callback that is used to validate the new value.</param>
            <param name="targetBackingField">The reference to the backing field.</param>
            <param name="methodConfiguration">A <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> object to configure the behavior of the method.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="validationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="validationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c>) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="value"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilent``1(``0,System.Func{``0,System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}},``0@,System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes a validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="value">The new value which is to be set to the property.</param>
            <param name="validationDelegate">The callback that is used to validate the new value.</param>
            <param name="targetBackingField">The reference to the backing field.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. If this optional parameter is not provided <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="validationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="validationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="value"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilent``1(``0,System.Func{``0,System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}},``0@,System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes a validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="value">The new value which is to be set to the property.</param>
            <param name="validationDelegate">The callback that is used to validate the new value.</param>
            <param name="targetBackingField">The reference to the backing field.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="validationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="validationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="value"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilent``1(``0,BionicCode.Utilities.Net.PropertyValidationDelegate{``0},``0@,BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes a validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="value">The new value which is to be set to the property.</param>
            <param name="validationDelegate">The callback that is used to validate the new value.</param>
            <param name="targetBackingField">The reference to the backing field.</param>
            <param name="methodConfiguration">A <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> object to configure the behavior of the method.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. If this optional parameter is not provided <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="validationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="validationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c>) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="value"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilent``1(``0,BionicCode.Utilities.Net.PropertyValidationDelegate{``0},``0@,BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes a validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="value">The new value which is to be set to the property.</param>
            <param name="validationDelegate">The callback that is used to validate the new value.</param>
            <param name="targetBackingField">The reference to the backing field.</param>
            <param name="methodConfiguration">A <see cref="T:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions"/> object to configure the behavior of the method.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="validationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="validationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c>) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="value"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilent``1(``0,BionicCode.Utilities.Net.PropertyValidationDelegate{``0},``0@,System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes a validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="value">The new value which is to be set to the property.</param>
            <param name="validationDelegate">The callback that is used to validate the new value.</param>
            <param name="targetBackingField">The reference to the backing field.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. If this optional parameter is not provided <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="validationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="validationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="value"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilent``1(``0,BionicCode.Utilities.Net.PropertyValidationDelegate{``0},``0@,System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes a validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="value">The new value which is to be set to the property.</param>
            <param name="validationDelegate">The callback that is used to validate the new value.</param>
            <param name="targetBackingField">The reference to the backing field.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="validationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="validationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="value"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilentAsync``1(``0,``0,System.Func{``0,System.Threading.Tasks.Task{System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}}},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes an asynchronous validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="newValue">The new value which is to be set to the property.</param>
            <param name="oldValue">The current value.</param>
            <param name="asyncValidationDelegate">The asynchronous callback that is used to validate the new value.</param>
            <param name="backingFieldSetterDelegate"></param>
            <param name="methodConfiguration"></param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. If this optional parameter is not provided <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="asyncValidationDelegate"/> is <c>NULL</c>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="asyncValidationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c>) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="newValue"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilentAsync``1(``0,``0,System.Func{``0,System.Threading.Tasks.Task{System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}}},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes an asynchronous validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="newValue">The new value which is to be set to the property.</param>
            <param name="oldValue">The current value.</param>
            <param name="asyncValidationDelegate">The asynchronous callback that is used to validate the new value.</param>
            <param name="backingFieldSetterDelegate"></param>
            <param name="methodConfiguration"></param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="asyncValidationDelegate"/> is <c>NULL</c>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="asyncValidationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c>) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="newValue"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilentAsync``1(``0,``0,System.Func{``0,System.Threading.Tasks.Task{System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}}},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes an asynchronous validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="newValue">The new value which is to be set to the property.</param>
            <param name="oldValue">The current value.</param>
            <param name="asyncValidationDelegate">The asynchronous callback that is used to validate the new value.</param>
            <param name="backingFieldSetterDelegate"></param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. If this optional parameter is not provided <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="asyncValidationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="asyncValidationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="newValue"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilentAsync``1(``0,``0,System.Func{``0,System.Threading.Tasks.Task{System.ValueTuple{System.Boolean,System.Collections.Generic.IEnumerable{System.Object}}}},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes an asynchronous validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="newValue">The new value which is to be set to the property.</param>
            <param name="oldValue">The current value.</param>
            <param name="asyncValidationDelegate">The asynchronous callback that is used to validate the new value.</param>
            <param name="backingFieldSetterDelegate"></param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="asyncValidationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="asyncValidationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="newValue"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilentAsync``1(``0,``0,BionicCode.Utilities.Net.PropertyValidationDelegateAsync{``0},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes an asynchronous validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="newValue">The new value which is to be set to the property.</param>
            <param name="oldValue">The current value.</param>
            <param name="asyncValidationDelegate">The asynchronous callback that is used to validate the new value.</param>
            <param name="backingFieldSetterDelegate"></param>
            <param name="methodConfiguration"></param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. If this optional parameter is not provided <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="asyncValidationDelegate"/> is <c>NULL</c>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="asyncValidationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c>) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="newValue"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilentAsync``1(``0,``0,BionicCode.Utilities.Net.PropertyValidationDelegateAsync{``0},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions,System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes an asynchronous validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="newValue">The new value which is to be set to the property.</param>
            <param name="oldValue">The current value.</param>
            <param name="asyncValidationDelegate">The asynchronous callback that is used to validate the new value.</param>
            <param name="backingFieldSetterDelegate"></param>
            <param name="methodConfiguration"></param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="asyncValidationDelegate"/> is <c>NULL</c>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="methodConfiguration"/> is configured with <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> set to <c>true</c> and validation failed</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="asyncValidationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/> it is recommended to set <paramref name="methodConfiguration"/> property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsThrowExceptionOnValidationErrorEnabled"/> to <c>true</c>.
            <br/>If not doing so, the binding target will clear the new value and show the last valid value instead.
            <br/>If equality checking is enabled by setting the <paramref name="methodConfiguration"/> parameter's property <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.SetValueOptions.IsRejectEqualValuesEnabled"/> to <c>true</c> (the parameter defaults to <c>true</c>) and the new value equals the old value, then the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event won't be raised. 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="newValue"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilentAsync``1(``0,``0,BionicCode.Utilities.Net.PropertyValidationDelegateAsync{``0},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},System.Collections.Generic.IEqualityComparer{``0},System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes an asynchronous validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="newValue">The new value which is to be set to the property.</param>
            <param name="oldValue">The current value.</param>
            <param name="asyncValidationDelegate">The asynchronous callback that is used to validate the new value.</param>
            <param name="backingFieldSetterDelegate"></param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <param name="equalityComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to check for value equality. If this optional parameter is not provided <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> will be used.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="asyncValidationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="asyncValidationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="newValue"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.TrySetValueSilentAsync``1(``0,``0,BionicCode.Utilities.Net.PropertyValidationDelegateAsync{``0},BionicCode.Utilities.Net.SetBackingFieldDelegate{``0},System.String)">
            <summary>
             Silently sets the value of the referenced property without raising <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> and executes an asynchronous validation delegate.
            </summary>
            <typeparam name="TValue">The generic value type parameter</typeparam>
            <param name="newValue">The new value which is to be set to the property.</param>
            <param name="oldValue">The current value.</param>
            <param name="asyncValidationDelegate">The asynchronous callback that is used to validate the new value.</param>
            <param name="backingFieldSetterDelegate"></param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="asyncValidationDelegate"/> is <c>NULL</c>.</exception>
            <returns>Returns <c>true</c> if the new value doesn't equal the old value and the new value is valid. Returns <c>false</c> if the new value equals the old value or the validation has failed.</returns>
            <remarks>This property setter supports invalid value rejection, which means values are only assigned to the backing field if they are valid which is when the <paramref name="asyncValidationDelegate"/> return <c>true</c>.
            <br/> To support visual validation error feed back and proper behavior in <c>TwoWay</c> binding scenarios where the validation mode <c>Binding.ValidatesOnExceptions</c> of the <c>System.Windows.Binding</c> is set to <c>true</c>, 
            <br/>Equality checking is enabled by default and the method will check for reference equality using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/>.
            <para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="newValue"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.IsValueValid``1(``0,BionicCode.Utilities.Net.PropertyValidationDelegate{``0},System.String)">
            <summary>
            Can be used to check whether a value is valid.
            </summary>
            <typeparam name="TValue">Generic type parameter of the value to check.</typeparam>
            <param name="value">The value to check.</param>
            <param name="validationDelegate">The validation delegate <see cref="T:System.Func`2"/>which is invoked on the value.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <returns><c>true</c> when the value is valid, otherwise <c>false</c>.</returns>
            <remarks><para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="value"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.IsValueValidAsync``1(``0,BionicCode.Utilities.Net.PropertyValidationDelegateAsync{``0},System.String)">
            <summary>
            Can be used to check whether a value is valid.
            </summary>
            <typeparam name="TValue">Generic type parameter of the value to check.</typeparam>
            <param name="value">The value to check.</param>
            <param name="asyncValidationDelegate">The validation delegate <see cref="T:System.Func`2"/>which is invoked on the value.</param>
            <param name="propertyName">The name of the property to set. Default name is the property that called this method.
            <br/>Use <c>null</c> to validate the value without generating an error.</param>
            <returns><c>true</c> when the value is valid, otherwise <c>false</c>.</returns>
            <remarks><para>When the <paramref name="propertyName"/> value is <c>null</c>, the <paramref name="value"/> is validated without generating an error. Validation errors are always related to a particular property.</para></remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.IsPropertyAttributeValid``1(``0,System.String)">
            <summary>
            Validates the value of a particular property against decorating validation attributes.
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="value">The value to validate.</param>
            <param name="propertyName">The name of the property to validate.</param>
            <returns><c>true</c> if validation passed or the property is not decorated with any validation attributes. Otherwise <c>false</c>.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.ClearErrors(System.String)">
            <summary>
            Removes all error objects related to a property.
            </summary>
            <param name="propertyName">The property to clear error objects  for.</param>
            <returns><c>true</c> if an item was removed or <c>false</c> if no item was removed or the property was not found.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.PropertyHasError(System.String)">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.GetPropertyErrors(System.String)">
            <inheritdoc />
        </member>
        <member name="E:BionicCode.Utilities.Net.ViewModelCommon.PropertyChanged">
            <summary>
            Event fired whenever a child property changes its value.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.OnPropertyChanged(System.String)">
            <summary>
            Method called to fire a <see cref="E:BionicCode.Utilities.Net.ViewModelCommon.PropertyChanged"/> event.
            Also raises the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event to support binding.
            </summary>
            <param name="propertyName"> The property name. </param>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.OnPropertyChanged(System.Object,System.Object,System.String)">
            <summary>
            Method called to fire a <see cref="E:BionicCode.Utilities.Net.ViewModelCommon.PropertyChanged"/> event.
            Also raises the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> event to support binding.
            </summary>
            <param name="propertyName"> The property name. </param>
            <param name="oldValue">The value before the property change.</param>
            <param name="newValue">The value after the property change.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.GetErrors(System.String)">
            <summary>
            Gets all error messages of the specified property. If the <paramref name="propertyName"/> is <c>null</c> all error messages will be returned.
            </summary>
            <param name="propertyName">The of the property of which the error messages should be returned.</param>
            <returns>An <see cref="T:System.Collections.IEnumerable"/> containing all error messages of the specified property.</returns>
            <remarks>If the <paramref name="propertyName"/> is <c>null</c> all current error messages will be returned.</remarks>
        </member>
        <member name="P:BionicCode.Utilities.Net.ViewModelCommon.HasErrors">
            <inheritdoc />
        </member>
        <member name="E:BionicCode.Utilities.Net.ViewModelCommon.ErrorsChanged">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.OnProgress(BionicCode.Utilities.Net.ProgressData)">
            <summary>
            When overridden, handles the <see cref="M:System.IProgress`1.Report(`0)"/> that is invoked by the <see cref="T:System.IProgress`1"/> instance returned from <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.CreateProgressReporterFromCurrentThread"/>. Can be used as progress delegate for any <see cref="T:System.IProgress`1"/>.
            </summary>
            <param name="progress">The progress argument.</param>
            <remarks>The default implementation provides the following logic: a value of <see cref="F:System.Double.NegativeInfinity"/> or <see cref="F:BionicCode.Utilities.Net.ViewModelCommon.DisableIndeterminateMode"/> will automatically set the <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.IsIndeterminate"/> property to <c>false</c>. A value of <see cref="F:System.Double.PositiveInfinity"/> or <see cref="F:BionicCode.Utilities.Net.ViewModelCommon.EnableIndeterminateMode"/> will automatically set the <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.IsIndeterminate"/> property to <c>true</c>.
            </remarks>
        </member>
        <member name="F:BionicCode.Utilities.Net.ViewModelCommon.EnableIndeterminateMode">
            <summary>
            Constant representing value of <see cref="F:System.Double.PositiveInfinity"/>. When assigned to <see cref="P:BionicCode.Utilities.Net.ProgressData.Progress"/> and when calling the default implementation of <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.OnProgress(BionicCode.Utilities.Net.ProgressData)"/> the value will automatically set <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.IsIndeterminate"/> to <c>true</c>.
            </summary>
        </member>
        <member name="F:BionicCode.Utilities.Net.ViewModelCommon.DisableIndeterminateMode">
            <summary>
            Constant representing value of <see cref="F:System.Double.NegativeInfinity"/>. When assigned to <see cref="P:BionicCode.Utilities.Net.ProgressData.Progress"/> and when calling the default implementation of <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.OnProgress(BionicCode.Utilities.Net.ProgressData)"/> the value will automatically set <see cref="P:BionicCode.Utilities.Net.ViewModelCommon.IsIndeterminate"/> to <c>false</c>.
            </summary>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.CreateProgressReporterFromCurrentThread">
            <summary>
            Creates a <see cref="T:System.IProgress`1"/> instance that is associated with the caller's thread.
            The registered progress callback is the virtual <c><see cref="T:BionicCode.Utilities.Net.ViewModelCommon"/>.OnProgress(ProgressData)</c> member.
            </summary>
            <remarks>To create a <see cref="T:System.IProgress`1"/> instance that is associated with the application's primary dispatcher thread of a Windows targeting application, for example to update properties that bind to a <c>DispatcherObject</c>, call <c>CreateProgressReporterFromUiThread</c>.</remarks>
            <returns>A <see cref="T:System.IProgress`1"/> instance that posts progress to the thread <see cref="M:BionicCode.Utilities.Net.ViewModelCommon.CreateProgressReporterFromCurrentThread"/> was called from.</returns>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.OnProgressChanged(System.Double,System.Double)">
            <summary>
            
            Raises the <see cref="E:BionicCode.Utilities.Net.IProgressReporterCommon.ProgressChanged"/> event.
            </summary>
            <param name="oldValue">The old progress value.</param>
            <param name="newValue">The new progress value.</param>
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.OnProgressChanged(System.Double,System.Double,System.String)">
            <summary>
            Raises the <see cref="E:BionicCode.Utilities.Net.IProgressReporterCommon.ProgressChanged"/> event.
            </summary>
            <param name="oldValue">The old progress value.</param>
            <param name="newValue">The new progress value.</param>
            <param name="progressText">The progress message.</param>
        </member>
        <member name="P:BionicCode.Utilities.Net.ViewModelCommon.IsReportingProgress">
            <inheritdoc/>
        </member>
        <member name="P:BionicCode.Utilities.Net.ViewModelCommon.IsIndeterminate">
            <inheritdoc/>
        </member>
        <member name="P:BionicCode.Utilities.Net.ViewModelCommon.ProgressText">
            <inheritdoc/>
        </member>
        <member name="P:BionicCode.Utilities.Net.ViewModelCommon.ProgressValue">
            <inheritdoc/>
        </member>
        <member name="E:BionicCode.Utilities.Net.ViewModelCommon.ProgressChanged">
            <inheritdoc/>
        </member>
        <member name="E:BionicCode.Utilities.Net.ViewModelCommon.PropertyValueChanged">
            <inheritdoc />
        </member>
        <member name="M:BionicCode.Utilities.Net.ViewModelCommon.OnErrorsChanged(System.String)">
            <summary>
            Raised when the validation state of the view model has changed (e.g. error added or removed).
            </summary>
            <param name="propertyName"></param>
        </member>
        <member name="T:BionicCode.Utilities.Net.DelegateSignatureEqualityComparer">
            <summary>
            Compares two delegates for equality.
            </summary>
            <remarks>
            This equality comparison differs from the default implementation of <see cref="M:System.Delegate.Equals(System.Object)"/> and <see cref="M:System.MulticastDelegate.Equals(System.Object)"/>
            in that it does not compare the delegate type. Different delegate types that reference the same target and have method signature and invocation list are considered equal.
            <br/>
            For example:
            <code>
            Action&lt;object, EventArgs&gt; action = SomeMethod;
            EventHandler&lt;EventArgs&gt; eventHandler = SomeMethod;
            
            // Using the default comparison
            bool isEqual = action.Equals(eventHandler); // FALSE
            
            // Using DelegateEqualityComparer comparison
            var delegateSignatureEqualityComparer = new DelegateSignatureEqualityComparer();
            isEqual = delegateSignatureEqualityComparer.Equals(action, eventHandler); // TRUE
            
            private void SomeMethod(object, EventArgs)
            {
            }
            </code>
            The two delegates do not have to be of the same type in order to be considered equal.
            <para/>
            Two <see cref="T:System.Delegate"/> are compared for equality as follows:
            <list type="number">
            <item>
            The <see cref="P:System.Delegate.Method"/> values are compared using <see cref="M:System.Reflection.MethodInfo.Equals(System.Object)"/> to ensure one of the following conditions is true:
              <list type="bullet">
                <item>
                  If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.
                </item>
                <item>
                   If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal.
                </item>
                <item>
                  Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.
                </item>
              </list>
            </item>
            <item>
            The <see cref="P:System.Delegate.Target"/> values are compared using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> to ensure one of the following conditions is true:
              <list type="bullet">
                <item>
                  If the two delegate targets being compared are both <see langword="null"/> (in case of static methods), the targets are considered equal and the targets are also considered equal.
                </item>
                <item>
                  If the two delegate targets being compared are the same instance, the targets are considered equal.
                </item>
                <item>
                  Otherwise, the delegate targets are not considered to be equal.
                </item>
              </list>
            </item>
            <item>
            The invocation lists are compared to ensure all of the following conditions are satisfied:
              <list type="bullet">
                <item>
                  Both invocation lists contain the same number of elements.
                </item>
                <item>
                  Both invocation lists are ordered exactly the same,
                  where both rules 1) and 2) must be satisfied. 
                  <br/>This means every element in the invocation list of the first delegate is equal to the corresponding element in the invocation list of the second delegate.
                </item>
              </list>
            </item>
            </list> 
            </remarks>
        </member>
        <member name="M:BionicCode.Utilities.Net.DelegateSignatureEqualityComparer.Equals(System.Delegate,System.Delegate)">
            <summary>
            Compares two delegates for equality.
            </summary>
            <remarks>
            This equality comparison differs from the default implementation of <see cref="M:System.Delegate.Equals(System.Object)"/> and <see cref="M:System.MulticastDelegate.Equals(System.Object)"/>
            in that it does not compare the delegate type. Different delegate types that reference the same target and have method signature and invocation list are considered equal.
            <br/>
            For example:
            <code>
            Action&lt;object, EventArgs&gt; action = SomeMethod;
            EventHandler&lt;EventArgs&gt; eventHandler = SomeMethod;
            
            // Using the default comparison
            bool isEqual = action.Equals(eventHandler); // FALSE
            
            // Using DelegateEqualityComparer comparison
            var delegateSignatureEqualityComparer = new DelegateSignatureEqualityComparer();
            isEqual = delegateSignatureEqualityComparer.Equals(action, eventHandler); // TRUE
            
            private void SomeMethod(object, EventArgs)
            {
            }
            </code>
            The two delegates do not have to be of the same type in order to be considered equal.
            <para/>
            Two <see cref="T:System.Delegate"/> are compared for equality as follows:
            <list type="number">
            <item>
            The <see cref="P:System.Delegate.Method"/> values are compared using <see cref="M:System.Reflection.MethodInfo.Equals(System.Object)"/> to ensure one of the following conditions is true:
              <list type="bullet">
                <item>
                  If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.
                </item>
                <item>
                   If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal.
                </item>
                <item>
                  Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.
                </item>
              </list>
            </item>
            <item>
            The <see cref="P:System.Delegate.Target"/> values are compared using <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)"/> to ensure one of the following conditions is true:
              <list type="bullet">
                <item>
                  If the two delegate targets being compared are both <see langword="null"/> (in case of static methods), the targets are considered equal and the targets are also considered equal.
                </item>
                <item>
                  If the two delegate targets being compared are the same instance, the targets are considered equal.
                </item>
                <item>
                  Otherwise, the delegate targets are not considered to be equal.
                </item>
              </list>
            </item>
            <item>
            The invocation lists are considered identical when all of the following conditions are satisfied:
              <list type="bullet">
                <item>
                  Both invocation lists contain the same number of elements.
                </item>
                <item>
                  Both invocation lists are ordered exactly the same,
                  where both rules 1) and 2) must be satisfied. 
                  <br/>This means every element in the invocation list of the first delegate is equal to the corresponding element in the invocation list of the second delegate.
                </item>
              </list>
            </item>
            </list> 
            </remarks>
        </member>
        <member name="T:BionicCode.Utilities.Net.WeakEventManager">
            <summary>
            Provides a base class for the event manager that is used in the weak event pattern. The manager adds and removes listenerHandlerMap for events (or callbacks) that also use the pattern.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.WeakEventManager`2.DummyEventListenerForStaticEventHandlers">
            <summary>
            Event listener for static events (eventListenerHandlerMap that don't have a instance as target) used as key for storing static handlers in a table.
            </summary>
        </member>
        <member name="T:BionicCode.Utilities.Net.WeakEventManager`2.DummyEventSourceForStaticEventHandlers">
            <summary>
            Event listener for static events (eventListenerHandlerMap that don't have a instance as target) used as key for storing static handlers in a table.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DependencyInjection.AddFactory``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
            Register <see cref="T:System.Func`1"/> factory implementations
            </summary>
            <typeparam name="TService"></typeparam>
            <param name="serviceCollection"></param>
            <param name="productLifetime"></param>
            <returns><see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/></returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DependencyInjection.AddFactory``2(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
            Register <see cref="T:System.Func`1"/> factory implementations
            </summary>
            <typeparam name="TService"></typeparam>
            <param name="serviceCollection"></param>
            <returns><see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/></returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DependencyInjection.AddMultiExportSingleton``1(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Register a service implementation with multiple interfaces. 
            Use <see cref="M:Microsoft.Extensions.DependencyInjection.IMultiExportServiceCollection.AsService``1"/> to attach more service interfaces to the service implementation <typeparamref name="TImplementation"/>
            or use <see cref="M:Microsoft.Extensions.DependencyInjection.IMultiExportServiceCollection.AsImplementedServices"/> to register all implemented interfaces of the implementation.
            </summary>
            <typeparam name="TImplementation"></typeparam>
            <param name="serviceCollection"></param>
            <returns>An <see cref="T:Microsoft.Extensions.DependencyInjection.IMultiExportServiceCollection"/> which implements <see cref="T:System.Collections.ICollection"/> and aggreagates multiple service interfaces mapped to a single implementation.</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DependencyInjection.AddSingletonAsInitializableService``2(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Register an <see cref="T:BionicCode.Utilities.Net.IInitializable"/> implementation.
            </summary>
            <typeparam name="TService"></typeparam>
            <typeparam name="TImplementation"></typeparam>
            <param name="serviceCollection"></param>
            <returns><see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/></returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DependencyInjection.AddSingletonAsInitializableService``1(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Register <see cref="T:BionicCode.Utilities.Net.IInitializable"/> implementations
            </summary>
            <typeparam name="TImplementation"></typeparam>
            <param name="serviceCollection"></param>
            <returns><see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/></returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DependencyInjection.TryInitializeServicesAsync(System.IServiceProvider)">
            <summary>
            Initializes asll registered <see cref="T:BionicCode.Utilities.Net.IInitializable"/> implementations.
            </summary>
            <param name="serviceProvider"></param>
            <returns><see cref="T:System.IServiceProvider"/></returns>
            <remarks>
            Use <see cref="M:Microsoft.Extensions.DependencyInjection.DependencyInjection.InitializeServicesAsync(System.IServiceProvider)"/> to throw an <see cref="T:System.InvalidOperationException"/> when the initialization of an <see cref="T:BionicCode.Utilities.Net.IInitializable"/> implementations has failed. 
            <br/>
            This is when <see cref="M:BionicCode.Utilities.Net.IInitializable.InitializeAsync"/> or <see cref="P:BionicCode.Utilities.Net.IInitializable.IsInitialized"/> returns <c>false</c>.
            </remarks>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DependencyInjection.InitializeServicesAsync(System.IServiceProvider)">
            <summary>
            Initializes all registered <see cref="T:BionicCode.Utilities.Net.IInitializable"/> implementations.
            </summary>
            <param name="serviceProvider"></param>
            <returns><see cref="T:System.IServiceProvider"/></returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the initialization of an <see cref="T:BionicCode.Utilities.Net.IInitializable"/> implementations has failed. This is when <see cref="M:BionicCode.Utilities.Net.IInitializable.InitializeAsync"/> or <see cref="P:BionicCode.Utilities.Net.IInitializable.IsInitialized"/> returns <c>false</c>.</exception>
            <remarks>
            Throws and <see cref="T:System.InvalidOperationException"/> when the initialization of an <see cref="T:BionicCode.Utilities.Net.IInitializable"/> implementations has failed. <br/>
            This is when <see cref="M:BionicCode.Utilities.Net.IInitializable.InitializeAsync"/> or <see cref="P:BionicCode.Utilities.Net.IInitializable.IsInitialized"/> returns <c>false</c>.
            <para>Use <see cref="M:Microsoft.Extensions.DependencyInjection.DependencyInjection.TryInitializeServicesAsync(System.IServiceProvider)"/> to avoid throwing such an exception and proceed with the initialization.</para>
            </remarks>
        </member>
        <member name="T:Microsoft.Extensions.DependencyInjection.IAssemblyFilter">
            <summary>
            Register type exporst/services from a particular assembly.
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.IMultiExportServiceCollection.AsService``1">
            <summary>
            Add another interface service to the implementation registered with a call to <see cref="M:Microsoft.Extensions.DependencyInjection.DependencyInjection.AddMultiExportSingleton``1(Microsoft.Extensions.DependencyInjection.IServiceCollection)"/>.
            </summary>
            <typeparam name="TService">Interface type or base type.</typeparam>
            <returns>An <see cref="T:Microsoft.Extensions.DependencyInjection.IMultiExportServiceCollection"/> which implements <see cref="T:System.Collections.ICollection"/> and allows to map multiple services with an implementation.</returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.IMultiExportServiceCollection.AsImplementedServices">
            <summary>
            Map all implemented interfaces and the potential base class to the implementation 
            previously registered with a call to <see cref="M:Microsoft.Extensions.DependencyInjection.DependencyInjection.AddMultiExportSingleton``1(Microsoft.Extensions.DependencyInjection.IServiceCollection)"/>.
            </summary>
            <returns>An <see cref="T:Microsoft.Extensions.DependencyInjection.IServiceCollection"/> to enable method chaining.</returns>
            <remarks>Ensure that all required dependencies are registered before calling this method.</remarks>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.MultiExportServiceCollection.AsService``1">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.MultiExportServiceCollection.AsImplementedServices">
            <inheritdoc/>
        </member>
    </members>
</doc>
